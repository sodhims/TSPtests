import ctypes as _c
import signal
import platform
import os
import sys
import inspect
import time
import array
import numbers

########


__version__ = "13.5.20250217"
__author__ = "Hexaly"
__copyright__ = "Copyright Hexaly, all rights reserved"
__email__ = "contact@hexaly.com"
__status__ = "Production"
__all__ = [
    "HexalyOptimizer", "HxError", "HxState", "HxSolutionStatus", "HxObjectiveDirection",
    "HxCallbackType", "HxOperator", "HxErrorCode", "HxInterval", "HxArray",
    "HxModel", "HxSolution", "HxStatistics", "HxExpression", "HxExternalContext",
    "HxSurrogateParameters", "HxExternalArgumentValues", "HxEvaluationPoint",
    "HxParam", "HxCollection", "HxInconsistency", "HxPhase","HxVersion", "version"
]


########


class HxContainer(object):
    def __init__(self, colname, lenfunc, getfunc):
        self.colname = colname
        self.lenfunc = lenfunc
        self.getfunc = getfunc

    def __nonzero__(self):
        return True

    def __len__(self):
        return self.lenfunc()

    def __getitem__(self, key):
        if isinstance(key, int) and (key >= self.lenfunc() or key < 0):
            raise IndexError
        return self.getfunc(key)

    def __str__(self):
        return "collection of <" + self.colname + "> containing " + str(self.lenfunc()) + " item(s)"

    def __contains__(self, other):
        for e in self:
            if e == other:
                return True
        return False

    def count(self):
        return self.lenfunc()

    def index(self, other):
        idx = 0
        for e in self:  
            if e == other:
                return True
            idx += 1
        return False


class HxMutableContainer(HxContainer):
    def __init__(self, colname, lenfunc, getfunc, setfunc):
        self.colname = colname
        self.lenfunc = lenfunc
        self.getfunc = getfunc
        self.setfunc = setfunc

    def __setitem__(self, key, value):
        if isinstance(key, int) and key >= self.lenfunc():
            raise IndexError
        return self.setfunc(key, value)


class HxMutableDict(object):
    def __init__(self, colname, getfunc, setfunc):
        self.__dict__["_colname"] = colname
        self.__dict__["_getfunc"] = getfunc
        self.__dict__["_setfunc"] = setfunc

    def __nonzero__(self):
        return True

    def __getitem__(self, key):
        return self._getfunc(key)

    def __getattr__(self, key):
        return self.__getitem__(key)

    def __setitem__(self, key, value):
        self._setfunc(key, value)

    def __setattr__(self, key, value):
        self.__setitem__(key, value)

    def __str__(self):
        return "collection of <" + self._colname + ">"

########

class HxEnumMeta(type):
    def __new__(mcs, name, bases, dico):
        enum_by_name = {}
        enum_by_value = [None for x in dico if x.isupper()]
        dico["_enum_by_name"] = enum_by_name
        dico["_enum_by_value"] = enum_by_value

        enum_class = super(HxEnumMeta, mcs).__new__(mcs, name, bases, dico)
        
        # Now replace members by equivalent enum members...
        for e in dico.items():
            if e[0].isupper():
                member = enum_class.__new__(enum_class)
                member.__dict__["name"] = e[0]
                member.__dict__["value"] = e[1]
                setattr(enum_class, e[0], member)
                enum_by_name[e[0]] = member
                enum_by_value[e[1]] = member

        return enum_class
        
    def __getattr__(cls, name):
        if name in cls.__dict__['_enum_by_name']:
            return cls.__dict__['_enum_by_name']
        raise AttributeError(name)

    def __setattr__(cls, name, value):
        if name in cls.__dict__['_enum_by_name']:
            raise AttributeError("Cannot reassign HxEnum members.")
        super(HxEnumMeta, cls).__setattr__(name, value)

    def __delattr__(cls, name):
        if name in cls.__dict__['_enum_by_name']:
            raise AttributeError("Cannot delete HxEnum members.")
        super(HxEnumMeta, cls).__delattr__(name)

    def __len__(cls):
        return len(cls.__dict__["_enum_by_name"])

    def __str__(cls):
        return str([x.name for x in cls.__dict__["_enum_by_value"] if x is not None])

    def __getitem__(cls, pos):
        return cls.__dict__["_enum_by_value"][pos]

    def __iter__(cls):
        return cls.__dict__["_enum_by_value"].__iter__()

    def __repr__(cls):
        return "<HxEnum %r>" % cls.__name__


def hx_with_metaclass(meta, *bases):
    class metaclass(meta):
        def __new__(cls, name, _, d):
            return meta(name, bases, d)
    return type.__new__(metaclass, 'temporary_class', (), {})


#pylint: disable=inherit-non-class
class HxEnum(hx_with_metaclass(HxEnumMeta, object)):
    def __repr__(self):
        return "<%s.%s: %r>" % (self.__class__.__name__, self.name, self.value)

    def __str__(self):
        return "%s.%s" % (self.__class__.__name__, self.name)

    def __hash__(self):
        return hash(self.__dict__["name"])

    def __setattr__(self, _name, _value):
        raise AttributeError

    def __delattr__(self, _name):
        raise AttributeError


########


class HxError(Exception):
    __slots__ = "error_code", "explanation", "file_name", "function_name", "line_number", "message"

    def __init__(self, errcode, explanation, filename, funcname, lineno):
        self.error_code = errcode
        self.explanation = explanation
        self.file_name = filename
        self.function_name = funcname
        self.line_number = lineno
        self.message = "ERROR [function " + funcname + "]: " + explanation

    def __repr__(self):
        return self.message

    def __str__(self):
        return self.message

########


class HxCallbackType(HxEnum):
    PHASE_STARTED = 0
    PHASE_ENDED = 1
    DISPLAY = 2
    TIME_TICKED = 3
    ITERATION_TICKED = 4

########


class HxErrorCode(HxEnum):
    API = 0
    FILE = 1
    MODEL = 2
    CALLBACK = 3
    LICENSE = 4
    SOLVER = 5
    INTERNAL = 6
    MODELER = 7
    CLOUD = 8


########


class HxObjectiveDirection(HxEnum):
    MINIMIZE = 0
    MAXIMIZE = 1


########


class HxOperator(HxEnum):
    BOOL = 0
    FLOAT = 1
    CONST = 2
    SUM = 3
    SUB = 4
    PROD = 5
    MAX = 6
    MIN = 7
    EQ = 8
    NEQ = 9
    GEQ = 10
    LEQ = 11
    GT = 12
    LT = 13
    IIF = 14
    NOT = 15
    AND = 16
    OR = 17
    XOR = 18
    ABS = 19
    DIST = 20
    DIV = 21
    MOD = 22
    ARRAY = 23
    AT = 24
    SCALAR = 25
    CEIL = 26
    FLOOR = 27
    ROUND = 28
    SQRT = 29
    LOG = 30
    EXP = 31
    POW = 32
    COS = 33
    SIN = 34
    TAN = 35
    INT = 36
    PIECEWISE = 37
    LIST = 38
    COUNT = 39
    INDEXOF = 40
    PARTITION = 41
    DISJOINT = 42
    EXTERNAL_FUNCTION = 43
    CALL = 44
    LAMBDA_FUNCTION = 45
    ARGUMENT = 46
    RANGE = 47
    CONTAINS = 48
    SET = 49
    DEPRECATED = 50
    COVER = 51
    FIND = 52
    SORT = 53
    INTERVAL = 54
    START = 55
    END = 56
    LENGTH = 57
    DISTINCT = 58
    INTERSECTION = 59
    HULL = 60
    STEP_ARRAY = 61
    CONST_ARRAY = 62
    UNION = 63

########


class HxSolutionStatus(HxEnum):
    INCONSISTENT = 0
    INFEASIBLE = 1
    FEASIBLE = 2
    OPTIMAL = 3

########


class HxState(HxEnum):
    MODELING = 0
    RUNNING = 1
    PAUSED = 2
    STOPPED = 3

########


class _hxinterval(_c.Structure):
    _fields_ = [('start', _c.c_longlong),
                ('end', _c.c_longlong)]

class _hxcallbackparams(_c.Structure):
    _fields_ = [('iterationBetweenTicks', _c.c_longlong),
            ('timeBetweenTicks', _c.c_int),
            ('system', _c.c_bool)]

_lhx = None
_pending_error = None
_chained_signal_handler = {}
_lib_name = None
_lib_candidates = []

if platform.system() == "Windows": _lib_name = "hexaly135.dll"
elif platform.system() == "Linux": _lib_name = "libhexaly135.so"
elif platform.system() == "Darwin": _lib_name = "libhexaly135.dylib"
else: raise ImportError("Cannot determine the underlying platform of your Python distribution. "
                        + "Please note that Hexaly Optimizer is compatible with Windows, Linux and macOS only. "
                        + "Any other system is not officially supported")

# Try two different locations to load the native library:
# 1. The current folder (used, among others, by the python wheel)
# 2. The system folders (delegates the loading behavior to the system)
_lib_candidates.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), _lib_name))
_lib_candidates.append(_lib_name)

_loaded_library = None
for candidate in _lib_candidates:
    try:
        # Python 3.8 has changed the behavior of CDLL on Windows.
        if hasattr(os, 'add_dll_directory'):
            _lhx = _c.CDLL(candidate, winmode = 0)
        else:
            _lhx = _c.CDLL(candidate)
        _loaded_library = candidate
        break
    except:
        pass

if _loaded_library is None:
    raise ImportError("Cannot load or find library " + _lib_name + ". Please ensure that Hexaly is correctly installed on your system")

def _hx_signal_handler(sig, frame):
    global _chained_signal_handler
    global _pending_error
    try:
        if _chained_signal_handler[sig] == signal.SIG_DFL:
            raise KeyboardInterrupt()
        if _chained_signal_handler[sig] != signal.SIG_IGN:
            _chained_signal_handler[sig](sig, frame)
    except:
        _pending_error = sys.exc_info()[1]
        _hx_interrupt(_encode_string(repr(_pending_error)), None)
        raise

def _hx_define_signal_handler(signame):
    try:
        if not hasattr(signal, signame): return
        sig = getattr(signal, signame)
        if signal.getsignal(sig) == _hx_signal_handler: return
        _chained_signal_handler[sig] = signal.signal(sig, _hx_signal_handler)
    except:
        pass

_hx_define_signal_handler("SIGINT")

def _hx_check_errors(result, _1, _2):
    global _pending_error
    if _pending_error is not None:
        err = _pending_error
        _pending_error = None
        # false positive (solved with the last versions of pylint)
        #pylint: disable=raising-bad-type
        raise err
    return result

def _hx_set_pending_error(ex):
    global _pending_error
    _pending_error = ex

def _hx_python_exception_hook(code, message, filename, funcname, lineno, _):
    global _pending_error
    if _pending_error is not None:
        return
    _pending_error = HxError(
        HxErrorCode[code],
        message.decode('utf-8'),
        filename.decode('utf-8'),
        funcname.decode('utf-8'),
        lineno)

_hx_create_optimizer = _lhx.hx_create_optimizer
_hx_create_optimizer.argtypes = []
_hx_create_optimizer.restype = _c.c_void_p
_hx_create_optimizer.errcheck = _hx_check_errors

_hx_delete_optimizer = _lhx.hx_delete_optimizer
_hx_delete_optimizer.argtypes = [_c.c_void_p]
_hx_delete_optimizer.restype = None
_hx_delete_optimizer.errcheck = _hx_check_errors

_hx_state = _lhx.hx_state
_hx_state.argtypes = [_c.c_void_p]
_hx_state.restype = _c.c_int
_hx_state.errcheck = _hx_check_errors

_hx_solve = _lhx.hx_solve
_hx_solve.argtypes = [_c.c_void_p]
_hx_solve.restype = None
_hx_solve.errcheck = _hx_check_errors

_hx_stop = _lhx.hx_stop
_hx_stop.argtypes = [_c.c_void_p]
_hx_stop.restype = None
_hx_stop.errcheck = _hx_check_errors

_hx_interrupt = _lhx.hx_interrupt
_hx_interrupt.argtypes = [_c.c_char_p, _c.c_void_p]
_hx_interrupt.restype = None

_hx_save_environment = _lhx.hx_save_environment
_hx_save_environment.argtypes = [_c.c_void_p, _c.c_char_p]
_hx_save_environment.restype = None
_hx_save_environment.errcheck = _hx_check_errors

_hx_load_environment = _lhx.hx_load_environment
_hx_load_environment.argtypes = [_c.c_void_p, _c.c_char_p]
_hx_load_environment.restype = None
_hx_load_environment.errcheck = _hx_check_errors

_hx_stats = _lhx.hx_stats
_hx_stats.argtypes = [_c.c_void_p]
_hx_stats.restype = _c.c_void_p
_hx_stats.errcheck = _hx_check_errors

_hx_params = _lhx.hx_params
_hx_params.argtypes = [_c.c_void_p]
_hx_params.restype = _c.c_void_p
_hx_params.errcheck = _hx_check_errors

_hx_best_solution = _lhx.hx_best_solution
_hx_best_solution.argtypes = [_c.c_void_p]
_hx_best_solution.restype = _c.c_void_p
_hx_best_solution.errcheck = _hx_check_errors

_hx_to_string = _lhx.hx_to_string
_hx_to_string.argtypes = [_c.c_void_p, _c.c_char_p, _c.c_int]
_hx_to_string.restype = _c.c_int
_hx_to_string.errcheck = _hx_check_errors

_hx_compute_iis = _lhx.hx_compute_iis
_hx_compute_iis.argtypes = [_c.c_void_p]
_hx_compute_iis.restype = None
_hx_compute_iis.errcheck = _hx_check_errors

_hx_iis_cause = _lhx.hx_iis_cause
_hx_iis_cause.argtypes = [_c.c_void_p, _c.c_int]
_hx_iis_cause.restype = _c.c_int
_hx_iis_cause.errcheck = _hx_check_errors

_hx_iis_nb_causes = _lhx.hx_iis_nb_causes
_hx_iis_nb_causes.argtypes = [_c.c_void_p]
_hx_iis_nb_causes.restype = _c.c_int
_hx_iis_nb_causes.errcheck = _hx_check_errors

_hx_iis_to_string = _lhx.hx_iis_to_string
_hx_iis_to_string.argtypes = [_c.c_void_p, _c.c_char_p, _c.c_int]
_hx_iis_to_string.restype = _c.c_int
_hx_iis_to_string.errcheck = _hx_check_errors

_hx_callback_type = _c.CFUNCTYPE(None, _c.c_void_p, _c.c_int, _c.c_void_p)

_hx_add_callback = _lhx.hx_add_callback
_hx_add_callback.argtypes = [_c.c_void_p, _c.c_int, _hx_callback_type, _c.c_void_p]
_hx_add_callback.restype = None
_hx_add_callback.errcheck = _hx_check_errors

_hx_add_callback_2 = _lhx.hx_add_callback_2
_hx_add_callback_2.argtypes = [_c.c_void_p, _c.c_int, _hx_callback_type, _c.POINTER(_hxcallbackparams), _c.c_void_p]
_hx_add_callback_2.restype = None
_hx_add_callback_2.errcheck = _hx_check_errors

_hx_remove_callback = _lhx.hx_remove_callback
_hx_remove_callback.argtypes = [_c.c_void_p, _c.c_int, _c.c_void_p]
_hx_remove_callback.restype = _c.c_bool
_hx_remove_callback.errcheck = _hx_check_errors

_hx_remove_callback_2 = _lhx.hx_remove_callback_2
_hx_remove_callback_2.argtypes = [_c.c_void_p, _c.c_int, _c.c_void_p, _c.c_void_p]
_hx_remove_callback_2.restype = _c.c_bool
_hx_remove_callback_2.errcheck = _hx_check_errors

_hx_log_writer_type = _c.CFUNCTYPE(None, _c.c_void_p, _c.c_char_p, _c.c_int, _c.c_void_p)

_hx_set_log_writer = _lhx.hx_set_log_writer
_hx_set_log_writer.argtypes = [_c.c_void_p, _hx_log_writer_type, _c.c_void_p, _c.c_int]
_hx_set_log_writer.restype = None
_hx_set_log_writer.errcheck = _hx_check_errors

_hx_add_phase = _lhx.hx_add_phase
_hx_add_phase.argtypes = [_c.c_void_p]
_hx_add_phase.restype = _c.c_void_p
_hx_add_phase.errcheck = _hx_check_errors

_hx_phase = _lhx.hx_phase
_hx_phase.argtypes = [_c.c_void_p, _c.c_int]
_hx_phase.restype = _c.c_void_p
_hx_phase.errcheck = _hx_check_errors

_hx_nb_phases = _lhx.hx_nb_phases
_hx_nb_phases.argtypes = [_c.c_void_p]
_hx_nb_phases.restype = _c.c_int
_hx_nb_phases.errcheck = _hx_check_errors

_hx_phase_params = _lhx.hx_phase_params
_hx_phase_params.argtypes = [_c.c_void_p]
_hx_phase_params.restype = _c.c_void_p
_hx_phase_params.errcheck = _hx_check_errors

_hx_phase_to_string = _lhx.hx_phase_to_string
_hx_phase_to_string.argtypes = [_c.c_void_p, _c.c_char_p, _c.c_int]
_hx_phase_to_string.restype = _c.c_int
_hx_phase_to_string.errcheck = _hx_check_errors

_hx_attrs_is_defined = _lhx.hx_attrs_is_defined
_hx_attrs_is_defined.argtypes = [_c.c_void_p, _c.c_char_p]
_hx_attrs_is_defined.restype = _c.c_bool
_hx_attrs_is_defined.errcheck = _hx_check_errors

_hx_attrs_type = _lhx.hx_attrs_type
_hx_attrs_type.argtypes = [_c.c_void_p, _c.c_char_p]
_hx_attrs_type.restype = _c.c_int
_hx_attrs_type.errcheck = _hx_check_errors

_hx_attrs_get_bool = _lhx.hx_attrs_get_bool
_hx_attrs_get_bool.argtypes = [_c.c_void_p, _c.c_char_p]
_hx_attrs_get_bool.restype = _c.c_bool
_hx_attrs_get_bool.errcheck = _hx_check_errors

_hx_attrs_set_bool = _lhx.hx_attrs_set_bool
_hx_attrs_set_bool.argtypes = [_c.c_void_p, _c.c_char_p, _c.c_bool]
_hx_attrs_set_bool.restype = None
_hx_attrs_set_bool.errcheck = _hx_check_errors

_hx_attrs_get_int = _lhx.hx_attrs_get_int
_hx_attrs_get_int.argtypes = [_c.c_void_p, _c.c_char_p]
_hx_attrs_get_int.restype = _c.c_int
_hx_attrs_get_int.errcheck = _hx_check_errors

_hx_attrs_set_int = _lhx.hx_attrs_set_int
_hx_attrs_set_int.argtypes = [_c.c_void_p, _c.c_char_p, _c.c_int]
_hx_attrs_set_int.restype = None
_hx_attrs_set_int.errcheck = _hx_check_errors

_hx_attrs_get_llong = _lhx.hx_attrs_get_llong
_hx_attrs_get_llong.argtypes = [_c.c_void_p, _c.c_char_p]
_hx_attrs_get_llong.restype = _c.c_longlong
_hx_attrs_get_llong.errcheck = _hx_check_errors

_hx_attrs_set_llong = _lhx.hx_attrs_set_llong
_hx_attrs_set_llong.argtypes = [_c.c_void_p, _c.c_char_p, _c.c_longlong]
_hx_attrs_set_llong.restype = None
_hx_attrs_set_llong.errcheck = _hx_check_errors

_hx_attrs_get_double = _lhx.hx_attrs_get_double
_hx_attrs_get_double.argtypes = [_c.c_void_p, _c.c_char_p]
_hx_attrs_get_double.restype = _c.c_double
_hx_attrs_get_double.errcheck = _hx_check_errors

_hx_attrs_set_double = _lhx.hx_attrs_set_double
_hx_attrs_set_double.argtypes = [_c.c_void_p, _c.c_char_p, _c.c_double]
_hx_attrs_set_double.restype = None
_hx_attrs_set_double.errcheck = _hx_check_errors

_hx_attrs_get_string = _lhx.hx_attrs_get_string
_hx_attrs_get_string.argtypes = [_c.c_void_p, _c.c_char_p, _c.c_char_p, _c.c_int]
_hx_attrs_get_string.restype = _c.c_int
_hx_attrs_get_string.errcheck = _hx_check_errors

_hx_attrs_set_string = _lhx.hx_attrs_set_string
_hx_attrs_set_string.argtypes = [_c.c_void_p, _c.c_char_p, _c.c_char_p]
_hx_attrs_set_string.restype = None
_hx_attrs_set_string.errcheck = _hx_check_errors

_hx_attrs_to_string = _lhx.hx_attrs_to_string
_hx_attrs_to_string.argtypes = [_c.c_void_p, _c.c_char_p, _c.c_int]
_hx_attrs_to_string.restype = _c.c_int
_hx_attrs_to_string.errcheck = _hx_check_errors

_hx_close = _lhx.hx_close
_hx_close.argtypes = [_c.c_void_p]
_hx_close.restype = None
_hx_close.errcheck = _hx_check_errors

_hx_open = _lhx.hx_open
_hx_open.argtypes = [_c.c_void_p]
_hx_open.restype = None
_hx_open.errcheck = _hx_check_errors

_hx_is_closed = _lhx.hx_is_closed
_hx_is_closed.argtypes = [_c.c_void_p]
_hx_is_closed.restype = _c.c_bool
_hx_is_closed.errcheck = _hx_check_errors

_hx_create_int_constant = _lhx.hx_create_int_constant
_hx_create_int_constant.argtypes = [_c.c_void_p, _c.c_longlong]
_hx_create_int_constant.restype = _c.c_int
_hx_create_int_constant.errcheck = _hx_check_errors

_hx_create_double_constant = _lhx.hx_create_double_constant
_hx_create_double_constant.argtypes = [_c.c_void_p, _c.c_double]
_hx_create_double_constant.restype = _c.c_int
_hx_create_double_constant.errcheck = _hx_check_errors

_hx_create_int_const_array = _lhx.hx_create_int_const_array
_hx_create_int_const_array.argtypes = [_c.c_void_p, _c.c_size_t, _c.c_int]
_hx_create_int_const_array.restype = _c.c_int
_hx_create_int_const_array.errcheck = _hx_check_errors

_hx_create_double_const_array = _lhx.hx_create_double_const_array
_hx_create_double_const_array.argtypes = [_c.c_void_p, _c.c_size_t, _c.c_int]
_hx_create_double_const_array.restype = _c.c_int
_hx_create_double_const_array.errcheck = _hx_check_errors

_hx_int_native_function_type = _c.CFUNCTYPE(_c.c_longlong, _c.c_void_p, _c.c_void_p, _c.c_void_p)
_hx_double_native_function_type = _c.CFUNCTYPE(_c.c_double, _c.c_void_p, _c.c_void_p, _c.c_void_p)
_hx_array_native_function_type = _c.CFUNCTYPE(None, _c.c_void_p, _c.c_void_p, _c.c_void_p, _c.c_void_p)

_hx_create_int_external_function = _lhx.hx_create_int_external_function
_hx_create_int_external_function.argtypes = [_c.c_void_p, _hx_int_native_function_type, _c.c_void_p]
_hx_create_int_external_function.restype = _c.c_int
_hx_create_int_external_function.errcheck = _hx_check_errors

_hx_create_double_external_function = _lhx.hx_create_double_external_function
_hx_create_double_external_function.argtypes = [_c.c_void_p, _hx_double_native_function_type, _c.c_void_p]
_hx_create_double_external_function.restype = _c.c_int
_hx_create_double_external_function.errcheck = _hx_check_errors

_hx_create_int_array_external_function = _lhx.hx_create_int_array_external_function
_hx_create_int_array_external_function.argtypes = [_c.c_void_p, _hx_array_native_function_type, _c.c_void_p]
_hx_create_int_array_external_function.restype = _c.c_int
_hx_create_int_array_external_function.errcheck = _hx_check_errors

_hx_create_double_array_external_function = _lhx.hx_create_double_array_external_function
_hx_create_double_array_external_function.argtypes = [_c.c_void_p, _hx_array_native_function_type, _c.c_void_p]
_hx_create_double_array_external_function.restype = _c.c_int
_hx_create_double_array_external_function.errcheck = _hx_check_errors

_hx_create_expression = _lhx.hx_create_expression
_hx_create_expression.argtypes = [_c.c_void_p, _c.c_int]
_hx_create_expression.restype = _c.c_int
_hx_create_expression.errcheck = _hx_check_errors

_hx_create_expression_1 = _lhx.hx_create_expression_1
_hx_create_expression_1.argtypes = [_c.c_void_p, _c.c_int, _c.c_int]
_hx_create_expression_1.restype = _c.c_int
_hx_create_expression_1.errcheck = _hx_check_errors

_hx_create_expression_2 = _lhx.hx_create_expression_2
_hx_create_expression_2.argtypes = [_c.c_void_p, _c.c_int, _c.c_int, _c.c_int]
_hx_create_expression_2.restype = _c.c_int
_hx_create_expression_2.errcheck = _hx_check_errors

_hx_create_expression_3 = _lhx.hx_create_expression_3
_hx_create_expression_3.argtypes = [_c.c_void_p, _c.c_int, _c.c_int, _c.c_int, _c.c_int]
_hx_create_expression_3.restype = _c.c_int
_hx_create_expression_3.errcheck = _hx_check_errors

_hx_create_expression_n = _lhx.hx_create_expression_n
_hx_create_expression_n.argtypes = [_c.c_void_p, _c.c_int, _c.c_size_t, _c.c_int]
_hx_create_expression_n.restype = _c.c_int
_hx_create_expression_n.errcheck = _hx_check_errors

_hx_nb_expressions = _lhx.hx_nb_expressions
_hx_nb_expressions.argtypes = [_c.c_void_p]
_hx_nb_expressions.restype = _c.c_int
_hx_nb_expressions.errcheck = _hx_check_errors

_hx_nb_constraints = _lhx.hx_nb_constraints
_hx_nb_constraints.argtypes = [_c.c_void_p]
_hx_nb_constraints.restype = _c.c_int
_hx_nb_constraints.errcheck = _hx_check_errors

_hx_nb_objectives = _lhx.hx_nb_objectives
_hx_nb_objectives.argtypes = [_c.c_void_p]
_hx_nb_objectives.restype = _c.c_int
_hx_nb_objectives.errcheck = _hx_check_errors

_hx_nb_decisions = _lhx.hx_nb_decisions
_hx_nb_decisions.argtypes = [_c.c_void_p]
_hx_nb_decisions.restype = _c.c_int
_hx_nb_decisions.errcheck = _hx_check_errors

_hx_nb_operands = _lhx.hx_nb_operands
_hx_nb_operands.argtypes = [_c.c_void_p]
_hx_nb_operands.restype = _c.c_int
_hx_nb_operands.errcheck = _hx_check_errors

_hx_constraint = _lhx.hx_constraint
_hx_constraint.argtypes = [_c.c_void_p, _c.c_int]
_hx_constraint.restype = _c.c_int
_hx_constraint.errcheck = _hx_check_errors

_hx_add_constraint = _lhx.hx_add_constraint
_hx_add_constraint.argtypes = [_c.c_void_p, _c.c_int]
_hx_add_constraint.restype = None
_hx_add_constraint.errcheck = _hx_check_errors

_hx_remove_constraint = _lhx.hx_remove_constraint
_hx_remove_constraint.argtypes = [_c.c_void_p, _c.c_int]
_hx_remove_constraint.restype = None
_hx_remove_constraint.errcheck = _hx_check_errors

_hx_remove_constraint_with_expr = _lhx.hx_remove_constraint_with_expr
_hx_remove_constraint_with_expr.argtypes = [_c.c_void_p, _c.c_int]
_hx_remove_constraint_with_expr.restype = None
_hx_remove_constraint_with_expr.errcheck = _hx_check_errors

_hx_objective = _lhx.hx_objective
_hx_objective.argtypes = [_c.c_void_p, _c.c_int]
_hx_objective.restype = _c.c_int
_hx_objective.errcheck = _hx_check_errors

_hx_objective_direction = _lhx.hx_objective_direction
_hx_objective_direction.argtypes = [_c.c_void_p, _c.c_int]
_hx_objective_direction.restype = _c.c_int
_hx_objective_direction.errcheck = _hx_check_errors

_hx_add_objective = _lhx.hx_add_objective
_hx_add_objective.argtypes = [_c.c_void_p, _c.c_int, _c.c_int]
_hx_add_objective.restype = None
_hx_add_objective.errcheck = _hx_check_errors

_hx_remove_objective = _lhx.hx_remove_objective
_hx_remove_objective.argtypes = [_c.c_void_p, _c.c_int]
_hx_remove_objective.restype = None
_hx_remove_objective.errcheck = _hx_check_errors

_hx_decision = _lhx.hx_decision
_hx_decision.argtypes = [_c.c_void_p, _c.c_int]
_hx_decision.restype = _c.c_int
_hx_decision.errcheck = _hx_check_errors

_hx_expression_with_name = _lhx.hx_expression_with_name
_hx_expression_with_name.argtypes = [_c.c_void_p, _c.c_char_p]
_hx_expression_with_name.restype = _c.c_int
_hx_expression_with_name.errcheck = _hx_check_errors

_hx_expr_is_objective = _lhx.hx_expr_is_objective
_hx_expr_is_objective.argtypes = [_c.c_void_p, _c.c_int]
_hx_expr_is_objective.restype = _c.c_bool
_hx_expr_is_objective.errcheck = _hx_check_errors

_hx_expr_is_decision = _lhx.hx_expr_is_decision
_hx_expr_is_decision.argtypes = [_c.c_void_p, _c.c_int]
_hx_expr_is_decision.restype = _c.c_bool
_hx_expr_is_decision.errcheck = _hx_check_errors

_hx_expr_is_constraint = _lhx.hx_expr_is_constraint
_hx_expr_is_constraint.argtypes = [_c.c_void_p, _c.c_int]
_hx_expr_is_constraint.restype = _c.c_bool
_hx_expr_is_constraint.errcheck = _hx_check_errors

_hx_expr_operator = _lhx.hx_expr_operator
_hx_expr_operator.argtypes = [_c.c_void_p, _c.c_int]
_hx_expr_operator.restype = _c.c_int
_hx_expr_operator.errcheck = _hx_check_errors

_hx_expr_type = _lhx.hx_expr_type
_hx_expr_type.argtypes = [_c.c_void_p, _c.c_int]
_hx_expr_type.restype = _c.c_int
_hx_expr_type.errcheck = _hx_check_errors

_hx_expr_subtype = _lhx.hx_expr_subtype
_hx_expr_subtype.argtypes = [_c.c_void_p, _c.c_int]
_hx_expr_subtype.restype = _c.c_int
_hx_expr_subtype.errcheck = _hx_check_errors

_hx_expr_attrs = _lhx.hx_expr_attrs
_hx_expr_attrs.argtypes = [_c.c_void_p, _c.c_int]
_hx_expr_attrs.restype = _c.c_void_p
_hx_expr_attrs.errcheck = _hx_check_errors

_hx_expr_nb_operands = _lhx.hx_expr_nb_operands
_hx_expr_nb_operands.argtypes = [_c.c_void_p, _c.c_int]
_hx_expr_nb_operands.restype = _c.c_int
_hx_expr_nb_operands.errcheck = _hx_check_errors

_hx_expr_operand = _lhx.hx_expr_operand
_hx_expr_operand.argtypes = [_c.c_void_p, _c.c_int, _c.c_int]
_hx_expr_operand.restype = _c.c_int
_hx_expr_operand.errcheck = _hx_check_errors

_hx_expr_set_operand = _lhx.hx_expr_set_operand
_hx_expr_set_operand.argtypes = [_c.c_void_p, _c.c_int, _c.c_int, _c.c_int]
_hx_expr_set_operand.restype = None
_hx_expr_set_operand.errcheck = _hx_check_errors

_hx_expr_add_operand = _lhx.hx_expr_add_operand
_hx_expr_add_operand.argtypes = [_c.c_void_p, _c.c_int, _c.c_int]
_hx_expr_add_operand.restype = None
_hx_expr_add_operand.errcheck = _hx_check_errors

_hx_expr_add_operands = _lhx.hx_expr_add_operands
_hx_expr_add_operands.argtypes = [_c.c_void_p, _c.c_int, _c.c_size_t, _c.c_int]
_hx_expr_add_operands.restype = None
_hx_expr_add_operands.errcheck = _hx_check_errors

_hx_expr_add_int_operands = _lhx.hx_expr_add_int_operands
_hx_expr_add_int_operands.argtypes = [_c.c_void_p, _c.c_int, _c.c_size_t, _c.c_int]
_hx_expr_add_int_operands.restype = None
_hx_expr_add_int_operands.errcheck = _hx_check_errors

_hx_expr_add_double_operands = _lhx.hx_expr_add_double_operands
_hx_expr_add_double_operands.argtypes = [_c.c_void_p, _c.c_int, _c.c_size_t, _c.c_int]
_hx_expr_add_double_operands.restype = None
_hx_expr_add_double_operands.errcheck = _hx_check_errors

_hx_expr_name = _lhx.hx_expr_name
_hx_expr_name.argtypes = [_c.c_void_p, _c.c_int, _c.c_char_p, _c.c_int]
_hx_expr_name.restype = _c.c_int
_hx_expr_name.errcheck = _hx_check_errors

_hx_expr_set_name = _lhx.hx_expr_set_name
_hx_expr_set_name.argtypes = [_c.c_void_p, _c.c_int, _c.c_char_p]
_hx_expr_set_name.restype = None
_hx_expr_set_name.errcheck = _hx_check_errors

_hx_expr_to_string = _lhx.hx_expr_to_string
_hx_expr_to_string.argtypes = [_c.c_void_p, _c.c_int, _c.c_char_p, _c.c_int]
_hx_expr_to_string.restype = _c.c_int
_hx_expr_to_string.errcheck = _hx_check_errors

_hx_model_to_string = _lhx.hx_model_to_string
_hx_model_to_string.argtypes = [_c.c_void_p, _c.c_char_p, _c.c_int]
_hx_model_to_string.restype = _c.c_int
_hx_model_to_string.errcheck = _hx_check_errors

_hx_int_objective_threshold = _lhx.hx_int_objective_threshold
_hx_int_objective_threshold.argtypes = [_c.c_void_p, _c.c_int]
_hx_int_objective_threshold.restype = _c.c_longlong
_hx_int_objective_threshold.errcheck = _hx_check_errors

_hx_double_objective_threshold = _lhx.hx_double_objective_threshold
_hx_double_objective_threshold.argtypes = [_c.c_void_p, _c.c_int]
_hx_double_objective_threshold.restype = _c.c_double
_hx_double_objective_threshold.errcheck = _hx_check_errors

_hx_set_int_objective_threshold = _lhx.hx_set_int_objective_threshold
_hx_set_int_objective_threshold.argtypes = [_c.c_void_p, _c.c_int, _c.c_longlong]
_hx_set_int_objective_threshold.restype = None
_hx_set_int_objective_threshold.errcheck = _hx_check_errors

_hx_set_double_objective_threshold = _lhx.hx_set_double_objective_threshold
_hx_set_double_objective_threshold.argtypes = [_c.c_void_p, _c.c_int, _c.c_double]
_hx_set_double_objective_threshold.restype = None
_hx_set_double_objective_threshold.errcheck = _hx_check_errors

_hx_create_evaluation_point = _lhx.hx_create_evaluation_point
_hx_create_evaluation_point.argtypes = [_c.c_void_p, _c.c_int]
_hx_create_evaluation_point.restype = _c.c_void_p
_hx_create_evaluation_point.errcheck = _hx_check_errors

_hx_nb_evaluation_points = _lhx.hx_nb_evaluation_points
_hx_nb_evaluation_points.argtypes = [_c.c_void_p, _c.c_int]
_hx_nb_evaluation_points.restype = _c.c_int
_hx_nb_evaluation_points.errcheck = _hx_check_errors

_hx_evaluation_point = _lhx.hx_evaluation_point
_hx_evaluation_point.argtypes = [_c.c_void_p, _c.c_int, _c.c_int]
_hx_evaluation_point.restype = _c.c_void_p
_hx_evaluation_point.errcheck = _hx_check_errors

_hx_solution_status = _lhx.hx_solution_status
_hx_solution_status.argtypes = [_c.c_void_p]
_hx_solution_status.restype = _c.c_int
_hx_solution_status.errcheck = _hx_check_errors

_hx_solution_clear = _lhx.hx_solution_clear
_hx_solution_clear.argtypes = [_c.c_void_p]
_hx_solution_clear.restype = None
_hx_solution_clear.errcheck = _hx_check_errors

_hx_solution_int_objective_bound = _lhx.hx_solution_int_objective_bound
_hx_solution_int_objective_bound.argtypes = [_c.c_void_p, _c.c_int]
_hx_solution_int_objective_bound.restype = _c.c_longlong
_hx_solution_int_objective_bound.errcheck = _hx_check_errors

_hx_solution_double_objective_bound = _lhx.hx_solution_double_objective_bound
_hx_solution_double_objective_bound.argtypes = [_c.c_void_p, _c.c_int]
_hx_solution_double_objective_bound.restype = _c.c_double
_hx_solution_double_objective_bound.errcheck = _hx_check_errors

_hx_solution_objective_gap = _lhx.hx_solution_objective_gap
_hx_solution_objective_gap.argtypes = [_c.c_void_p, _c.c_int]
_hx_solution_objective_gap.restype = _c.c_double
_hx_solution_objective_gap.errcheck = _hx_check_errors

_hx_solution_int_value = _lhx.hx_solution_int_value
_hx_solution_int_value.argtypes = [_c.c_void_p, _c.c_int]
_hx_solution_int_value.restype = _c.c_longlong
_hx_solution_int_value.errcheck = _hx_check_errors

_hx_solution_double_value = _lhx.hx_solution_double_value
_hx_solution_double_value.argtypes = [_c.c_void_p, _c.c_int]
_hx_solution_double_value.restype = _c.c_double
_hx_solution_double_value.errcheck = _hx_check_errors

_hx_solution_interval_value = _lhx.hx_solution_interval_value
_hx_solution_interval_value.argtypes = [_c.c_void_p, _c.c_int]
_hx_solution_interval_value.restype = _hxinterval
_hx_solution_interval_value.errcheck = _hx_check_errors

_hx_solution_buffer_value = _lhx.hx_solution_buffer_value
_hx_solution_buffer_value.argtypes = [_c.c_void_p, _c.c_int]
_hx_solution_buffer_value.restype = _c.c_void_p
_hx_solution_buffer_value.errcheck = _hx_check_errors

_hx_solution_is_violated = _lhx.hx_solution_is_violated
_hx_solution_is_violated.argtypes = [_c.c_void_p, _c.c_int]
_hx_solution_is_violated.restype = _c.c_bool
_hx_solution_is_violated.errcheck = _hx_check_errors

_hx_solution_is_undefined = _lhx.hx_solution_is_undefined
_hx_solution_is_undefined.argtypes = [_c.c_void_p, _c.c_int]
_hx_solution_is_undefined.restype = _c.c_bool
_hx_solution_is_undefined.errcheck = _hx_check_errors

_hx_solution_set_int_value = _lhx.hx_solution_set_int_value
_hx_solution_set_int_value.argtypes = [_c.c_void_p, _c.c_int, _c.c_longlong]
_hx_solution_set_int_value.restype = None
_hx_solution_set_int_value.errcheck = _hx_check_errors

_hx_solution_set_double_value = _lhx.hx_solution_set_double_value
_hx_solution_set_double_value.argtypes = [_c.c_void_p, _c.c_int, _c.c_double]
_hx_solution_set_double_value.restype = None
_hx_solution_set_double_value.errcheck = _hx_check_errors

_hx_solution_set_interval_value = _lhx.hx_solution_set_interval_value
_hx_solution_set_interval_value.argtypes = [_c.c_void_p, _c.c_int, _hxinterval]
_hx_solution_set_interval_value.restype = None
_hx_solution_set_interval_value.errcheck = _hx_check_errors

_hx_solution_collection_clear = _lhx.hx_solution_collection_clear
_hx_solution_collection_clear.argtypes = [_c.c_void_p, _c.c_int]
_hx_solution_collection_clear.restype = None
_hx_solution_collection_clear.errcheck = _hx_check_errors

_hx_solution_collection_add = _lhx.hx_solution_collection_add
_hx_solution_collection_add.argtypes = [_c.c_void_p, _c.c_int, _c.c_longlong]
_hx_solution_collection_add.restype = None
_hx_solution_collection_add.errcheck = _hx_check_errors

_hx_interval_to_string = _lhx.hx_interval_to_string
_hx_interval_to_string.argtypes = [_hxinterval, _c.c_char_p, _c.c_int]
_hx_interval_to_string.restype = _c.c_int
_hx_interval_to_string.errcheck = _hx_check_errors

_hx_buffer_count = _lhx.hx_buffer_count
_hx_buffer_count.argtypes = [_c.c_void_p]
_hx_buffer_count.restype = _c.c_int
_hx_buffer_count.errcheck = _hx_check_errors

_hx_buffer_type = _lhx.hx_buffer_type
_hx_buffer_type.argtypes = [_c.c_void_p, _c.c_int]
_hx_buffer_type.restype = _c.c_int
_hx_buffer_type.errcheck = _hx_check_errors

_hx_buffer_is_pos_undefined = _lhx.hx_buffer_is_pos_undefined
_hx_buffer_is_pos_undefined.argtypes = [_c.c_void_p, _c.c_int]
_hx_buffer_is_pos_undefined.restype = _c.c_bool
_hx_buffer_is_pos_undefined.errcheck = _hx_check_errors

_hx_buffer_get_int = _lhx.hx_buffer_get_int
_hx_buffer_get_int.argtypes = [_c.c_void_p, _c.c_int]
_hx_buffer_get_int.restype = _c.c_longlong
_hx_buffer_get_int.errcheck = _hx_check_errors

_hx_buffer_get_double = _lhx.hx_buffer_get_double
_hx_buffer_get_double.argtypes = [_c.c_void_p, _c.c_int]
_hx_buffer_get_double.restype = _c.c_double
_hx_buffer_get_double.errcheck = _hx_check_errors

_hx_buffer_get_interval = _lhx.hx_buffer_get_interval
_hx_buffer_get_interval.argtypes = [_c.c_void_p, _c.c_int]
_hx_buffer_get_interval.restype = _hxinterval
_hx_buffer_get_interval.errcheck = _hx_check_errors

_hx_buffer_get_buffer = _lhx.hx_buffer_get_buffer
_hx_buffer_get_buffer.argtypes = [_c.c_void_p, _c.c_int]
_hx_buffer_get_buffer.restype = _c.c_void_p
_hx_buffer_get_buffer.errcheck = _hx_check_errors

_hx_buffer_contains_int = _lhx.hx_buffer_contains_int
_hx_buffer_contains_int.argtypes = [_c.c_void_p, _c.c_longlong]
_hx_buffer_contains_int.restype = _c.c_bool
_hx_buffer_contains_int.errcheck = _hx_check_errors

_hx_buffer_contains_double = _lhx.hx_buffer_contains_double
_hx_buffer_contains_double.argtypes = [_c.c_void_p, _c.c_double]
_hx_buffer_contains_double.restype = _c.c_bool
_hx_buffer_contains_double.errcheck = _hx_check_errors

_hx_buffer_copy_int = _lhx.hx_buffer_copy_int
_hx_buffer_copy_int.argtypes = [_c.c_void_p, _c.POINTER(_c.c_longlong), _c.c_int]
_hx_buffer_copy_int.restype = None
_hx_buffer_copy_int.errcheck = _hx_check_errors

_hx_buffer_copy_double = _lhx.hx_buffer_copy_double
_hx_buffer_copy_double.argtypes = [_c.c_void_p, _c.POINTER(_c.c_double), _c.c_int]
_hx_buffer_copy_double.restype = None
_hx_buffer_copy_double.errcheck = _hx_check_errors

_hx_buffer_to_string = _lhx.hx_buffer_to_string
_hx_buffer_to_string.argtypes = [_c.c_void_p, _c.c_char_p, _c.c_int]
_hx_buffer_to_string.restype = _c.c_int
_hx_buffer_to_string.errcheck = _hx_check_errors

_hx_buffer_add_int = _lhx.hx_buffer_add_int
_hx_buffer_add_int.argtypes = [_c.c_void_p, _c.c_longlong]
_hx_buffer_add_int.restype = None
_hx_buffer_add_int.errcheck = _hx_check_errors

_hx_buffer_add_double = _lhx.hx_buffer_add_double
_hx_buffer_add_double.argtypes = [_c.c_void_p, _c.c_double]
_hx_buffer_add_double.restype = None
_hx_buffer_add_double.errcheck = _hx_check_errors

_hx_buffer_set_int = _lhx.hx_buffer_set_int
_hx_buffer_set_int.argtypes = [_c.c_void_p, _c.c_int, _c.c_longlong]
_hx_buffer_set_int.restype = None
_hx_buffer_set_int.errcheck = _hx_check_errors

_hx_buffer_set_double = _lhx.hx_buffer_set_double
_hx_buffer_set_double.argtypes = [_c.c_void_p, _c.c_int, _c.c_double]
_hx_buffer_set_double.restype = None
_hx_buffer_set_double.errcheck = _hx_check_errors

_hx_buffer_set_interval = _lhx.hx_buffer_set_interval
_hx_buffer_set_interval.argtypes = [_c.c_void_p, _c.c_int, _hxinterval]
_hx_buffer_set_interval.restype = None
_hx_buffer_set_interval.errcheck = _hx_check_errors

_hx_buffer_clear = _lhx.hx_buffer_clear
_hx_buffer_clear.argtypes = [_c.c_void_p]
_hx_buffer_clear.restype = None
_hx_buffer_clear.errcheck = _hx_check_errors

_hx_version_code = _lhx.hx_version_code
_hx_version_code.argtypes = []
_hx_version_code.restype = _c.c_int
_hx_version_code.errcheck = _hx_check_errors

_hx_globals = _lhx.hx_globals
_hx_globals.argtypes = []
_hx_globals.restype = _c.c_void_p
_hx_globals.errcheck = _hx_check_errors

_hx_exception_callback_type = _c.CFUNCTYPE(None, _c.c_int, _c.c_char_p, _c.c_char_p, _c.c_char_p, _c.c_int, _c.c_void_p)
_hx_set_exception_callback = _lhx.hx_set_exception_callback
_hx_set_exception_callback.argtypes = [_hx_exception_callback_type, _c.c_void_p]
_hx_set_exception_callback.restype = None
_exception_callback_ref = _hx_exception_callback_type(_hx_python_exception_hook)
_hx_set_exception_callback(_exception_callback_ref, None)

_hx_check_paused_or_stopped = _lhx.hx_check_paused_or_stopped
_hx_check_paused_or_stopped.argtypes = [_c.c_void_p]
_hx_check_paused_or_stopped.restype = _c.c_bool
_hx_check_paused_or_stopped.errcheck = _hx_check_errors

_hx_check_modeling_or_stopped = _lhx.hx_check_modeling_or_stopped
_hx_check_modeling_or_stopped.argtypes = [_c.c_void_p]
_hx_check_modeling_or_stopped.restype = _c.c_bool
_hx_check_modeling_or_stopped.errcheck = _hx_check_errors

_hx_check_not_running = _lhx.hx_check_not_running
_hx_check_not_running.argtypes = [_c.c_void_p]
_hx_check_not_running.restype = _c.c_bool
_hx_check_not_running.errcheck = _hx_check_errors

_hx_check_modeling = _lhx.hx_check_modeling
_hx_check_modeling.argtypes = [_c.c_void_p]
_hx_check_modeling.restype = _c.c_bool
_hx_check_modeling.errcheck = _hx_check_errors

_hx_check_stopped = _lhx.hx_check_stopped
_hx_check_stopped.argtypes = [_c.c_void_p]
_hx_check_stopped.restype = _c.c_bool
_hx_check_stopped.errcheck = _hx_check_errors

_hx_check_expr_index = _lhx.hx_check_expr_index
_hx_check_expr_index.argtypes = [_c.c_void_p, _c.c_int]
_hx_check_expr_index.restype = _c.c_bool
_hx_check_expr_index.errcheck = _hx_check_errors

_hx_check_expr_type = _lhx.hx_check_expr_type
_hx_check_expr_type.argtypes = [_c.c_void_p, _c.c_int, _c.c_int]
_hx_check_expr_type.restype = _c.c_bool
_hx_check_expr_type.errcheck = _hx_check_errors

_hx_check_buffer_type = _lhx.hx_check_buffer_type
_hx_check_buffer_type.argtypes = [_c.c_void_p, _c.c_int, _c.c_int]
_hx_check_buffer_type.restype = _c.c_bool
_hx_check_buffer_type.errcheck = _hx_check_errors

_hx_check_expr_subtype = _lhx.hx_check_expr_subtype
_hx_check_expr_subtype.argtypes = [_c.c_void_p, _c.c_int, _c.c_int]
_hx_check_expr_subtype.restype = _c.c_bool
_hx_check_expr_subtype.errcheck = _hx_check_errors

_hx_check_operator = _lhx.hx_check_operator
_hx_check_operator.argtypes = [_c.c_void_p, _c.c_int, _c.c_int]
_hx_check_operator.restype = _c.c_bool
_hx_check_operator.errcheck = _hx_check_errors

_hxm_optimizer_reset = _lhx.hxm_optimizer_reset
_hxm_optimizer_reset.argtypes = [_c.c_void_p];
_hxm_optimizer_reset.restype = None
_hxm_optimizer_reset.errcheck = _hx_check_errors

_hxm_inc_ref = _lhx.hxm_inc_ref
_hxm_inc_ref.argtypes = [_c.c_void_p]
_hxm_inc_ref.restype = None
_hxm_inc_ref.errcheck = _hx_check_errors

_hxm_dec_ref = _lhx.hxm_dec_ref
_hxm_dec_ref.argtypes = [_c.c_void_p]
_hxm_dec_ref.restype = None
_hxm_dec_ref.errcheck = _hx_check_errors

_HXVT_BOOL = 1
_HXVT_INT = 2
_HXVT_DOUBLE = 4
_HXVT_ARRAY = 8
_HXVT_COLLECTION = 16
_HXVT_FUNCTION = 32
_HXVT_INTERVAL = 64

_HXAVT_BOOL = 0
_HXAVT_INT = 1
_HXAVT_LONG_LONG = 2
_HXAVT_DOUBLE = 3
_HXAVT_STRING = 4



########


try:
    import numpy
    _HAS_NUMPY = True
except ImportError:
    _HAS_NUMPY = False

_string_buf = _c.create_string_buffer(1024)
_HX_PY2 = sys.version_info[0] == 2
_HX_PY_WITH_SIGNATURE = sys.version_info[0] > 3 or sys.version_info[0] == 3 and sys.version_info[1] >= 3
_HX_PY_WITH_Q_ARRAY = sys.version_info[0] > 3 or sys.version_info[0] == 3 and sys.version_info[1] >= 3

def _check_optimizer(optimizer):
    if optimizer._optimizer_ptr is None:
        raise HxError(HxErrorCode.API, "Cannot perform the asked operation on a deleted environment", "hxutils.py", "_check_optimizer", -1)

def _check_same_optimizer(optimizer1, optimizer2):
    if optimizer1 != optimizer2:
        raise HxError(HxErrorCode.API, "The given element does not belong to the same HexalyOptimizer instance", "hxutils.py", "_check_same_optimizer", -1)

def _check_readwrite_collection(expr_id):
    if expr_id is None:
        raise HxError(HxErrorCode.API, "This collection is read-only and cannot be modified", "hxutils.py", "_check_readwrite_collection", -1)

def _check_positive_argument(pos):
    if pos < 0:
        raise HxError(HxErrorCode.API, "Index out of bounds. Argument index must be positive but " + str(pos) + " provided.",
            "hxutils.py", "_check_positive_argument", -1)

def _check_enum(value, enum_type):
    if type(value) is not enum_type:
        raise TypeError("An enum member of type %s is expected" % enum_type.__name__)

def _encode_string(sstr):
    if sstr is None:
        return None
    return sstr.encode('utf-8')

def _encode_string_no_null(sstr):
    if sstr is None:
        return None
    raw_str = sstr.encode('utf-8')
    if b'\0' in raw_str:
        raise HxError(HxErrorCode.API, "String contains an unauthorized NULL character", "hxutils.py", "_encode_string_no_null", -1)
    return raw_str

def _encode_strings_no_null(sstrs):
    if sstrs is None:
        return None
    result = b""
    for sstr in sstrs:
        if sstr is None:
           raise HxError(HxErrorCode.API, "One of the string is None", "hxutils.py", "_encode_strings_no_null", -1)
        raw_str = _encode_string_no_null(sstr)
        result += raw_str + b'\0'
    return result

def _decode_subset_bytes(bbytes, length):
    if bbytes is None:
        return None
    return bbytes[:length].decode('utf-8')

def _read_string(func):
    global _string_buf
    size = func(_string_buf, len(_string_buf))
    if size > len(_string_buf):
        buf = _c.create_string_buffer(size)
        _string_buf = buf
        size = func(buf, len(buf))
    return _string_buf[:size].decode('utf-8')

def _nb_function_args(callval):
    if _HX_PY_WITH_SIGNATURE:
        #pylint: disable=no-member
        signature = inspect.signature(callval)
        return len(signature.parameters)
    else:
        args_def = inspect.getargspec(callval)[0]
        return len(args_def)

def _is_string(val):
    #pylint: disable=undefined-variable
    if _HX_PY2: string_type = basestring
    else: string_type = str
    return isinstance(val, string_type)

def _is_iterable(x):
    try:
        iter(x)
        return True
    except:
        return False

def _extract_python_number(x):
    if isinstance(x, int):
        return x
    elif isinstance(x, float):
        return x
    elif isinstance(x, numbers.Integral):
        return int(x)
    elif isinstance(x, numbers.Real):
        return float(x)
    else:
        raise TypeError("A number (int, float) is expected but %s of type %s was found" % (repr(x), repr(type(x))))

def _get_attr_value(attrs_ptr, name):
    raw_name = _encode_string_no_null(name)
    attr_type = _hx_attrs_type(attrs_ptr, raw_name)
    if attr_type == _HXAVT_BOOL: return _hx_attrs_get_bool(attrs_ptr, raw_name)
    elif attr_type == _HXAVT_INT: return _hx_attrs_get_int(attrs_ptr, raw_name)
    elif attr_type == _HXAVT_LONG_LONG: return _hx_attrs_get_llong(attrs_ptr, raw_name)
    elif attr_type == _HXAVT_DOUBLE: return _hx_attrs_get_double(attrs_ptr, raw_name)
    elif attr_type == _HXAVT_STRING: return _read_string(lambda buf, x: _hx_attrs_get_string(attrs_ptr, raw_name, buf, x))
    else: raise NotImplementedError

def _set_attr_value(attrs_ptr, name, value):
    raw_name = _encode_string_no_null(name)
    attr_type = _hx_attrs_type(attrs_ptr, raw_name)
    if attr_type == _HXAVT_BOOL: _hx_attrs_set_bool(attrs_ptr, raw_name, value)
    elif attr_type == _HXAVT_INT: _hx_attrs_set_int(attrs_ptr, raw_name, value)
    elif attr_type == _HXAVT_LONG_LONG: _hx_attrs_set_llong(attrs_ptr, raw_name, value)
    elif attr_type == _HXAVT_DOUBLE: _hx_attrs_set_double(attrs_ptr, raw_name, value)
    elif attr_type == _HXAVT_STRING: _hx_attrs_set_string(attrs_ptr, raw_name, _encode_string_no_null(value))

def _autocreate_expr(optimizer_ptr, expr):
    if isinstance(expr, HxExpression):
        _check_same_optimizer(optimizer_ptr, expr._optimizer_ptr)
        return expr._expr_id
    elif isinstance(expr, int):
        return _hx_create_int_constant(optimizer_ptr, expr)
    elif isinstance(expr, float):
        return _hx_create_double_constant(optimizer_ptr, expr)
    else:
        x = _extract_python_number(expr)
        if isinstance(x, int): return _hx_create_int_constant(optimizer_ptr, x)
        else: return _hx_create_double_constant(optimizer_ptr, x)

def _add_optimized_operands_buffer(optimizer_ptr, expr_id, operands, recursiver=None):
    expr_buf = None
    int_constants_buf = None
    double_constants_buf = None
    
    def _call_add_buffer(buffer, callee):
        if buffer is not None and len(buffer) > 0:
            buf_info = buffer.buffer_info()
            callee(optimizer_ptr, expr_id, buf_info[0], buf_info[1])
            del buffer[:]

    if _HAS_NUMPY and isinstance(operands, numpy.ndarray) and operands.ndim == 1:
        if numpy.issubdtype(operands.dtype, numpy.integer):
            c_array = numpy.ascontiguousarray(operands, dtype=numpy.int64).ctypes
            _hx_expr_add_int_operands(optimizer_ptr, expr_id, c_array.data, c_array.shape[0])
            return
        elif numpy.issubdtype(operands.dtype, numpy.floating):
            c_array = numpy.ascontiguousarray(operands, dtype=numpy.float64).ctypes
            _hx_expr_add_double_operands(optimizer_ptr, expr_id, c_array.data, c_array.shape[0])
            return
    try:
        iterator = iter(operands)
        op = next(iterator)
        while True:
            if isinstance(op, HxExpression):
                if expr_buf is None:
                    expr_buf = array.array('i')
                while isinstance(op, HxExpression):
                    expr_buf.append(op._expr_id)
                    op = next(iterator)
                _call_add_buffer(expr_buf, _hx_expr_add_operands)
                continue
            if _HX_PY_WITH_Q_ARRAY and (isinstance(op, int) or isinstance(op, numbers.Integral)):
                if int_constants_buf is None:
                    int_constants_buf = array.array('q')
                while isinstance(op, int) or isinstance(op, numbers.Integral):
                    int_constants_buf.append(int(op))
                    op = next(iterator)
                _call_add_buffer(int_constants_buf, _hx_expr_add_int_operands)
                continue
            if not _HX_PY_WITH_Q_ARRAY and (isinstance(op, int) or isinstance(op, numbers.Integral)):
                if expr_buf is None:
                    expr_buf = array.array('i')
                while isinstance(op, int) or isinstance(op, numbers.Integral):
                    expr_buf.append(_hx_create_int_constant(optimizer_ptr, int(op)))
                    op = next(iterator)
                _call_add_buffer(expr_buf, _hx_expr_add_operands)
                continue
            if isinstance(op, float) or isinstance(op, numbers.Real):
                if double_constants_buf is None:
                     double_constants_buf = array.array('d')
                while isinstance(op, float) or isinstance(op, numbers.Real):
                    double_constants_buf.append(float(op))
                    op = next(iterator)
                _call_add_buffer(double_constants_buf, _hx_expr_add_double_operands)
                continue
            if isinstance(op, str) == False and recursiver is not None and _is_iterable(op):
                if expr_buf is None:
                    expr_buf = array.array('i')
                while _is_iterable(op):
                    expr_buf.append(recursiver(op))
                    op = next(iterator)
                _call_add_buffer(expr_buf, _hx_expr_add_operands)
                continue

            raise TypeError("A number (int, float) is expected but %s of type %s was found" % (repr(op), repr(type(op))))
    except StopIteration:
        _call_add_buffer(expr_buf, _hx_expr_add_operands)
        _call_add_buffer(int_constants_buf, _hx_expr_add_int_operands)
        _call_add_buffer(double_constants_buf, _hx_expr_add_double_operands)

def _expr_create_variadic(optimizer_ptr, operator, ops):
    if hasattr(ops, "__len__") and len(ops) == 1 and _is_iterable(ops[0]):
        ops = ops[0]
    operands_buf = array.array('i')
    operands_buf.extend(map(lambda op: _autocreate_expr(optimizer_ptr, op), ops))
    buf_info = operands_buf.buffer_info()
    expr_id = _hx_create_expression_n(optimizer_ptr, operator, buf_info[0], buf_info[1])
    return expr_id

def _expr_create_0(optimizer_ptr, operator):
    return _hx_create_expression(optimizer_ptr, operator)

def _expr_create_1(optimizer_ptr, operator, op1):
    rop1 = _autocreate_expr(optimizer_ptr, op1)
    return _hx_create_expression_1(optimizer_ptr, operator, rop1)

def _expr_create_2(optimizer_ptr, operator, op1, op2):
    rop1 = _autocreate_expr(optimizer_ptr, op1)
    rop2 = _autocreate_expr(optimizer_ptr, op2)
    return _hx_create_expression_2(optimizer_ptr, operator, rop1, rop2)

def _expr_create_3(optimizer_ptr, operator, op1, op2, op3):
    rop1 = _autocreate_expr(optimizer_ptr, op1)
    rop2 = _autocreate_expr(optimizer_ptr, op2)
    rop3 = _autocreate_expr(optimizer_ptr, op3)
    return _hx_create_expression_3(optimizer_ptr, operator, rop1, rop2, rop3)

def _expr_add_operands(optimizer_ptr, expr_id, ops):
    if hasattr(ops, "__len__") and len(ops) == 1 and _is_iterable(ops[0]):
        ops = ops[0]
    _add_optimized_operands_buffer(optimizer_ptr, expr_id, ops)

def _find_expr_id(optimizer_ptr, expr):
    if isinstance(expr, HxExpression):
        _check_same_optimizer(optimizer_ptr, expr._optimizer_ptr)
        return expr._expr_id
    elif isinstance(expr, int):
        return expr
    else:
        raise TypeError("An HxExpression or an integer is expected but %s was found" % expr)

def _nb_function_args(callval):
    PYSIG = sys.version_info[0] > 3 or sys.version_info[0] == 3 and sys.version_info[1] >= 3
    if PYSIG:
        #pylint: disable=no-member
        signature = inspect.signature(callval)
        return len(signature.parameters)
    else:
        args_def = inspect.getargspec(callval)[0]
        return len(args_def)

def _check_restype(value, func_restype):
    if func_restype == _c.c_longlong and isinstance(value, numbers.Integral) == False:
        raise TypeError("A boolean or an integer is expected but %s was found" % repr(type(value)))

def _create_native_function(optimizer, func_type, func_creator, arg_class, func):
    _check_optimizer(optimizer)

    def native_function(_1, arg_values, _2):
        global _pending_error
        try:
            x = _extract_python_number(func(arg_class(optimizer, arg_values)))
            _check_restype(x, func_type._restype_)
            return x
        except:
            _pending_error = sys.exc_info()[1]
            _hx_interrupt(_encode_string(repr(_pending_error)), None)
            return 0

    native_func = func_type(native_function)
    optimizer._native_functions.append(native_func)
    func_id = func_creator(optimizer._optimizer_ptr, native_func, None)
    func_attrs = _hx_expr_attrs(optimizer._optimizer_ptr, func_id)
    _hx_attrs_set_bool(func_attrs, "fromGilLanguage".encode('utf-8'), True)
    return HxExpression(optimizer, func_id)

def _fill_array(array_ptr, array_value, array_type=None):
    try:
        _ = (k for k in array_value)
    except:
        raise HxError(HxErrorCode.API, "An iterable is expected but %s was found" % repr(type(array_value)), "hxutils.py", "_fill_array", -1)
    _hx_buffer_clear(array_ptr)
    for k in array_value:
        x = _extract_python_number(k)
        if isinstance(x, int):
            if array_type == None or array_type == _HXVT_INT:
                _hx_buffer_add_int(array_ptr, x)
            else:
                _hx_buffer_add_double(array_ptr, x)
        else:
            _hx_buffer_add_double(array_ptr, x)

def _create_array_native_function(optimizer, func_type, func_creator, arg_class, func, array_type):
    _check_optimizer(optimizer)

    def native_function(_1, arg_values, result, _2):
        global _pending_error
        try:
            res = func(arg_class(optimizer, arg_values))
            _fill_array(result, res, array_type)
        except:
            _pending_error = sys.exc_info()[1]
            _hx_interrupt(_encode_string(repr(_pending_error)), None)

    native_func = func_type(native_function)
    optimizer._native_functions.append(native_func)
    func_id = func_creator(optimizer._optimizer_ptr, native_func, None)
    func_attrs = _hx_expr_attrs(optimizer._optimizer_ptr, func_id)
    _hx_attrs_set_bool(func_attrs, "fromGilLanguage".encode('utf-8'), True)
    return HxExpression(optimizer, func_id)



########


class HxArray(object):
    __slots__ = "_optimizer", "_buffer_ptr"

    def __init__(self, optimizer, buffer_ptr):
        self._optimizer = optimizer
        self._buffer_ptr = buffer_ptr

    def count(self):
        _check_optimizer(self._optimizer)
        return _hx_buffer_count(self._buffer_ptr)

    def is_bool(self, pos):
        _check_optimizer(self._optimizer)
        return _hx_buffer_type(self._buffer_ptr, pos) == _HXVT_BOOL

    def is_int(self, pos):
        _check_optimizer(self._optimizer)
        buf_type = _hx_buffer_type(self._buffer_ptr, pos)
        return buf_type == _HXVT_INT or buf_type == _HXVT_BOOL

    def is_double(self, pos):
        _check_optimizer(self._optimizer)
        return _hx_buffer_type(self._buffer_ptr, pos) == _HXVT_DOUBLE

    def is_interval(self, pos):
        _check_optimizer(self._optimizer)
        return _hx_buffer_type(self._buffer_ptr, pos) == _HXVT_INTERVAL

    def is_array(self, pos):
        _check_optimizer(self._optimizer)
        return _hx_buffer_type(self._buffer_ptr, pos) == _HXVT_ARRAY

    def is_collection(self, pos):
        _check_optimizer(self._optimizer)
        return _hx_buffer_type(self._buffer_ptr, pos) == _HXVT_COLLECTION

    def is_undefined(self, pos):
        _check_optimizer(self._optimizer)
        return _hx_buffer_is_pos_undefined(self._buffer_ptr, pos)

    def get(self, pos):
        _check_optimizer(self._optimizer)
        buf_type = _hx_buffer_type(self._buffer_ptr, pos)
        if buf_type == _HXVT_INT or buf_type == _HXVT_BOOL:
            return _hx_buffer_get_int(self._buffer_ptr, pos)
        elif buf_type == _HXVT_DOUBLE:
            return _hx_buffer_get_double(self._buffer_ptr, pos)
        elif buf_type == _HXVT_INTERVAL:
            interval = _hx_buffer_get_interval(self._buffer_ptr, pos)
            return HxInterval(interval.start, interval.end)
        elif buf_type == _HXVT_ARRAY:
            return HxArray(self._optimizer, _hx_buffer_get_buffer(self._buffer_ptr, pos))
        elif buf_type == _HXVT_COLLECTION:
            return HxCollection(self._optimizer, _hx_buffer_get_buffer(self._buffer_ptr, pos))
        else:
            return None

    def __getitem__(self, pos):
        return self.get(pos)
    
    def __len__(self):
        return self.count()

    def __iter__(self):
        n = 0
        while n < self.count():
            yield self.get(n)
            n += 1

    def __str__(self):
        _check_optimizer(self._optimizer)
        return _read_string(lambda buf, x: _hx_buffer_to_string(self._buffer_ptr, buf, x))

    def __hash__(self):
        return self._buffer_ptr

    def __eq__(self, other):
        return (isinstance(other, HxArray)
            and self._buffer_ptr == other._buffer_ptr)

    def __ne__(self, other):
        return not self.__eq__(other)


########


class HxCollection(object):
    __slots__ = "_optimizer", "_buffer_ptr", "_solution_ptr", "_expr_id"

    def __init__(self, optimizer, buffer_ptr, solution_ptr=None, expr_id=None):
        self._optimizer = optimizer
        self._buffer_ptr = buffer_ptr
        self._solution_ptr = solution_ptr
        self._expr_id = expr_id

    def count(self):
        _check_optimizer(self._optimizer)
        return _hx_buffer_count(self._buffer_ptr)

    def get(self, pos):
        _check_optimizer(self._optimizer)
        return _hx_buffer_get_int(self._buffer_ptr, pos)

    def contains(self, value):
        _check_optimizer(self._optimizer)
        return _hx_buffer_contains_int(self._buffer_ptr, value)

    def add(self, val):
        _check_optimizer(self._optimizer)
        _check_readwrite_collection(self._solution_ptr)
        _hx_solution_collection_add(self._solution_ptr, self._expr_id, val)

    def clear(self):
        _check_optimizer(self._optimizer)
        _check_readwrite_collection(self._solution_ptr)
        _hx_solution_collection_clear(self._solution_ptr, self._expr_id)

    def __getitem__(self, pos):
        return self.get(pos)
    
    def __contains__(self, value):
        _check_optimizer(self._optimizer)
        return _hx_buffer_contains_int(self._buffer_ptr, value)

    def __len__(self):
        return self.count()

    def __iter__(self):
        n = 0
        while n < self.count():
            yield self.get(n)
            n += 1

    def __str__(self):
        _check_optimizer(self._optimizer)
        return _read_string(lambda buf, x: _hx_buffer_to_string(self._buffer_ptr, buf, x))

    def __hash__(self):
        return self._buffer_ptr

    def __eq__(self, other):
        return (isinstance(other, HxCollection)
                and self._buffer_ptr == other._buffer_ptr)

    def __ne__(self, other):
        return not self.__eq__(other)

########


class HxExternalContext(object):
    __slots__ = "_optimizer", "_attrs_ptr", "_func_id"

    def __init__(self, optimizer, func_id):
        self._optimizer = optimizer
        self._func_id = func_id
        self._attrs_ptr = _hx_expr_attrs(optimizer._optimizer_ptr, func_id)

    def get_lower_bound(self):
        _check_optimizer(self._optimizer)
        func_type = _hx_expr_subtype(self._optimizer._optimizer_ptr, self._func_id)
        if func_type == _HXVT_INT:
            return _hx_attrs_get_llong(self._attrs_ptr, _encode_string("intLowerBound"))
        elif func_type == _HXVT_DOUBLE:
            return _hx_attrs_get_double(self._attrs_ptr, _encode_string("doubleLowerBound"))
        else:
            raise TypeError("This function does not have a lower bound.")

    def set_lower_bound(self, lower_bound):
        _check_optimizer(self._optimizer)
        _hx_check_modeling(self._optimizer._optimizer_ptr)
        x = _extract_python_number(lower_bound)
        if isinstance(x, int):
            func_type = _hx_expr_subtype(self._optimizer._optimizer_ptr, self._func_id)
            if func_type == _HXVT_INT:
                _hx_attrs_set_llong(self._attrs_ptr, _encode_string("intLowerBound"), x)
            else:
                _hx_attrs_set_double(self._attrs_ptr, _encode_string("doubleLowerBound"), x)
        else:
            _hx_check_expr_subtype(self._optimizer._optimizer_ptr, self._func_id, _HXVT_DOUBLE)
            _hx_attrs_set_double(self._attrs_ptr, _encode_string("doubleLowerBound"), x)

    def get_upper_bound(self):
        _check_optimizer(self._optimizer)
        func_type = _hx_expr_subtype(self._optimizer._optimizer_ptr, self._func_id)
        if func_type == _HXVT_INT:
            return _hx_attrs_get_llong(self._attrs_ptr, _encode_string("intUpperBound"))
        elif func_type == _HXVT_DOUBLE:
            return _hx_attrs_get_double(self._attrs_ptr, _encode_string("doubleUpperBound"))
        else:
            raise TypeError("This function does not have an upper bound.")

    def set_upper_bound(self, upper_bound):
        _check_optimizer(self._optimizer)
        _hx_check_modeling(self._optimizer._optimizer_ptr)
        x = _extract_python_number(upper_bound)
        if isinstance(x, int):
            func_type = _hx_expr_subtype(self._optimizer._optimizer_ptr, self._func_id)
            if func_type == _HXVT_INT:
                _hx_attrs_set_llong(self._attrs_ptr, _encode_string("intUpperBound"), x)
            else:
                _hx_attrs_set_double(self._attrs_ptr, _encode_string("doubleUpperBound"), x)
        else:
            _hx_check_expr_subtype(self._optimizer._optimizer_ptr, self._func_id, _HXVT_DOUBLE)
            _hx_attrs_set_double(self._attrs_ptr, _encode_string("doubleUpperBound"), x)

    def is_nanable(self):
        _check_optimizer(self._optimizer)
        _hx_check_expr_subtype(self._optimizer._optimizer_ptr, self._func_id, _HXVT_DOUBLE)
        return _hx_attrs_get_bool(self._attrs_ptr, _encode_string("nanable"))

    def set_nanable(self, nanable):
        _check_optimizer(self._optimizer)
        _hx_check_modeling(self._optimizer._optimizer_ptr)
        _hx_check_expr_subtype(self._optimizer._optimizer_ptr, self._func_id, _HXVT_DOUBLE)
        _hx_attrs_set_bool(self._attrs_ptr, _encode_string("nanable"), nanable)

    def enable_surrogate_modeling(self):
        _check_optimizer(self._optimizer)
        _hx_check_modeling(self._optimizer._optimizer_ptr)
        _hx_attrs_set_bool(self._attrs_ptr, _encode_string("surrogateEnabled"), True)
        return HxSurrogateParameters(self._optimizer, self._func_id)

    lower_bound = property(get_lower_bound, set_lower_bound)
    upper_bound = property(get_upper_bound, set_upper_bound)
    nanable = property(is_nanable, set_nanable)

########


class HxInterval(object):
    __slots__ = "_start", "_end"

    def __init__(self, *args):
        self._start = 1
        self._end = 0
        if len(args) >= 1:
            self._start = args[0]
        if len(args) >= 2:
            self._end = args[1]
        
    def is_void(self):
        return self._start > self._end

    def is_degenerate(self):
        return self._start == self._end

    def start(self):
        if self.is_void():
            raise HxError(HxErrorCode.API, "This interval is void and has no valid bounds.", "hxinterval.py", "start", -1)
        return self._start
        
    def end(self):
        if self.is_void():
            raise HxError(HxErrorCode.API, "This interval is void and has no valid bounds.", "hxinterval.py", "end", -1)
        return self._end
        
    def count(self):
        if self.is_void():
            return 0
        return self._end - self._start

    def contains(self, value):
        if self.is_void():
            return False
        return self._start <= value and value < self._end

    def __contains__(self, value):
        if self.is_void():
            return False
        return self._start <= value and value < self._end

    def __len__(self):
        return self.count()

    def __iter__(self):
        for v in range(self._start, self._end):
            yield v

    def __str__(self):
        interval = _hxinterval()
        interval.start = self._start
        interval.end = self._end
        return _read_string(lambda buf, x: _hx_interval_to_string(interval, buf, x))

    def __hash__(self):
        if self.is_void():
            return 0
        return hash((self._start, self._end))

    def __eq__(self, other):
        if not isinstance(other, HxInterval):
            return False
        if self.is_void() and other.is_void():
            return True
        return self._start == other._start \
                and self._end == other._end

    def __ne__(self, other):
        return not self.__eq__(other)

########


class HxParam(object):
    __slots__ = "_optimizer", "_attrs_ptr", "_writer", "_writer_func"
    
    def __init__(self, optimizer):
        self._optimizer = optimizer
        self._attrs_ptr = _hx_params(optimizer._optimizer_ptr)
        self._writer = None
        self._writer_func = None

    def get_time_limit(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_int(self._attrs_ptr, _encode_string("timeLimit"))

    def set_time_limit(self, time_limit):
        _check_optimizer(self._optimizer)
        _hx_attrs_set_int(self._attrs_ptr, _encode_string("timeLimit"), time_limit)

    def get_iteration_limit(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_llong(self._attrs_ptr, _encode_string("iterationLimit"))

    def set_iteration_limit(self, iteration_limit):
        _check_optimizer(self._optimizer)
        _hx_attrs_set_llong(self._attrs_ptr, _encode_string("iterationLimit"), iteration_limit)

    def get_seed(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_int(self._attrs_ptr, _encode_string("seed"))

    def set_seed(self, seed):
        _check_optimizer(self._optimizer)
        _hx_attrs_set_int(self._attrs_ptr, _encode_string("seed"), seed)

    def get_nb_threads(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_int(self._attrs_ptr, _encode_string("nbThreads"))

    def set_nb_threads(self, nb_threads):
        _check_optimizer(self._optimizer)
        _hx_attrs_set_int(self._attrs_ptr, _encode_string("nbThreads"), nb_threads)

    def get_verbosity(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_int(self._attrs_ptr, _encode_string("verbosity"))

    def set_verbosity(self, verbosity):
        _check_optimizer(self._optimizer)
        _hx_attrs_set_int(self._attrs_ptr, _encode_string("verbosity"), verbosity)

    def get_time_between_displays(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_int(self._attrs_ptr, _encode_string("timeBetweenDisplays"))

    def set_time_between_displays(self, time_between_displays):
        _check_optimizer(self._optimizer)
        _hx_attrs_set_int(self._attrs_ptr, _encode_string("timeBetweenDisplays"), time_between_displays)

    def get_time_between_ticks(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_int(self._attrs_ptr, _encode_string("timeBetweenTicks"))

    def set_time_between_ticks(self, time_between_ticks):
        _check_optimizer(self._optimizer)
        _hx_attrs_set_int(self._attrs_ptr, _encode_string("timeBetweenTicks"), time_between_ticks)

    def get_iteration_between_ticks(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_llong(self._attrs_ptr, _encode_string("iterationBetweenTicks"))

    def set_iteration_between_ticks(self, iteration_between_ticks):
        _check_optimizer(self._optimizer)
        _hx_attrs_set_llong(self._attrs_ptr, _encode_string("iterationBetweenTicks"), iteration_between_ticks)

    def get_log_file(self):
        _check_optimizer(self._optimizer)
        return _read_string(lambda buf, size: _hx_attrs_get_string(self._attrs_ptr, _encode_string("logFile"), buf, size))

    def set_log_file(self, log_file):
        _check_optimizer(self._optimizer)
        _hx_attrs_set_string(self._attrs_ptr, _encode_string("logFile"), _encode_string_no_null(log_file))

    def get_log_writer(self):
        _check_optimizer(self._optimizer)
        return self._writer

    def set_log_writer(self, writer):
        _check_optimizer(self._optimizer)

        def writer_function(_1, message, length, _2):
            try:
                if writer is None:
                    return
                writer.write(_decode_subset_bytes(message, length))
                writer.flush()
            except:
                _pending_error = sys.exc_info()[1]
                _hx_interrupt(_encode_string(repr(_pending_error)), None)

        self._writer = writer
        self._writer_func = _hx_log_writer_type(writer_function)
        mode = self._extract_writer_mode(writer)
        _hx_set_log_writer(self._optimizer._optimizer_ptr, self._writer_func, None, mode)

    def _extract_writer_mode(self, writer):
        try:
            #pylint: disable=undefined-variable
            get_ipython()
            return 2 if writer == sys.stdout else 0
        except:
            return -1 if writer == sys.stdout and sys.stdout == sys.__stdout__ else 0

    def get_advanced_param(self, name):
        _check_optimizer(self._optimizer)
        if not _hx_attrs_is_defined(self._attrs_ptr, _encode_string_no_null(name)): return None
        return _get_attr_value(self._attrs_ptr, name)

    def set_advanced_param(self, name, value):
        _check_optimizer(self._optimizer)
        if not _hx_attrs_is_defined(self._attrs_ptr, _encode_string_no_null(name)): return
        _set_attr_value(self._attrs_ptr, name, value)

    def get_objective_threshold(self, pos):
        _check_optimizer(self._optimizer)
        expr_id = _hx_objective(self._optimizer._optimizer_ptr, pos)
        if _hx_expr_type(self._optimizer._optimizer_ptr, expr_id) == _HXVT_DOUBLE:
            return _hx_double_objective_threshold(self._optimizer._optimizer_ptr, pos)
        else:
            return _hx_int_objective_threshold(self._optimizer._optimizer_ptr, pos)

    def set_objective_threshold(self, pos, value):
        _check_optimizer(self._optimizer)
        x = _extract_python_number(value)
        if isinstance(x, int):
            expr_id = _hx_objective(self._optimizer._optimizer_ptr, pos)
            expr_type = _hx_expr_type(self._optimizer._optimizer_ptr, expr_id)
            if expr_type == _HXVT_INT or expr_type == _HXVT_BOOL:
                _hx_set_int_objective_threshold(self._optimizer._optimizer_ptr, pos, x)
            else:
                _hx_set_double_objective_threshold(self._optimizer._optimizer_ptr, pos, x)
        else:
            _hx_set_double_objective_threshold(self._optimizer._optimizer_ptr, pos, x)

    def __str__(self):
        _check_optimizer(self._optimizer)
        return _read_string(lambda buf, x: _hx_attrs_to_string(self._attrs_ptr, buf, x))

    def __eq__(self, other):
        return (isinstance(other, HxParam)
                and self._attrs_ptr == other._attrs_ptr)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return self._attrs_ptr

    time_limit = property(get_time_limit, set_time_limit)
    iteration_limit = property(get_iteration_limit, set_iteration_limit)
    seed = property(get_seed, set_seed)
    nb_threads = property(get_nb_threads, set_nb_threads)
    verbosity = property(get_verbosity, set_verbosity)
    
    time_between_displays = property(get_time_between_displays, set_time_between_displays)
    time_between_ticks = property(get_time_between_ticks, set_time_between_ticks)
    iteration_between_ticks = property(get_iteration_between_ticks, set_iteration_between_ticks)
    log_file = property(get_log_file, set_log_file)
    log_writer = property(get_log_writer, set_log_writer)
    advanced_params = property(lambda self: HxMutableDict("AdvancedParameter", self.get_advanced_param, self.set_advanced_param))


########


class HxPhase(object):
    __slots__ = "_optimizer", "_phase_ptr", "_params", "_stats"
    
    def __init__(self, optimizer, phase_ptr):
        self._optimizer = optimizer
        self._phase_ptr = phase_ptr
        self._params = _hx_phase_params(self._phase_ptr)

    def get_time_limit(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_int(self._params, _encode_string("timeLimit"))

    def set_time_limit(self, limit):
        _check_optimizer(self._optimizer)
        _hx_attrs_set_int(self._params, _encode_string("timeLimit"), limit)

    def get_iteration_limit(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_llong(self._params, _encode_string("iterationLimit"))

    def set_iteration_limit(self, limit):
        _check_optimizer(self._optimizer)
        _hx_attrs_set_llong(self._params, _encode_string("iterationLimit"), limit)

    def get_optimized_objective(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_int(self._params, _encode_string("optimizedObjective"))

    def set_optimized_objective(self, pos):
        _check_optimizer(self._optimizer)
        _hx_attrs_set_int(self._params, _encode_string("optimizedObjective"), pos)

    def is_enabled(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_bool(self._params, _encode_string("enabled"))

    def set_enabled(self, enabled):
        _check_optimizer(self._optimizer)
        _hx_attrs_set_bool(self._params, _encode_string("enabled"), enabled)

    def __str__(self):
        _check_optimizer(self._optimizer)
        return _read_string(lambda buf, x: _hx_phase_to_string(self._phase_ptr, buf, x))

    def __eq__(self, other):
        return (isinstance(other, HxPhase)
                and self._phase_ptr == other._phase_ptr)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return self._phase_ptr

    time_limit = property(get_time_limit, set_time_limit)
    iteration_limit = property(get_iteration_limit, set_iteration_limit)
    optimized_objective = property(get_optimized_objective, set_optimized_objective)
    enabled = property(is_enabled, set_enabled)


########


class HxStatistics(object):
    __slots__ = "_optimizer", "_attrs_ptr"

    def __init__(self, optimizer):
        self._optimizer = optimizer
        self._attrs_ptr = _hx_stats(optimizer._optimizer_ptr)

    def get_running_time(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_int(self._attrs_ptr, _encode_string("runningTime"))

    def get_nb_iterations(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_llong(self._attrs_ptr, _encode_string("nbIterations"))
        
    def get_nb_moves(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_llong(self._attrs_ptr, _encode_string("nbMoves"))
        
    def get_nb_accepted_moves(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_llong(self._attrs_ptr, _encode_string("nbAcceptedMoves"))

    def get_nb_improving_moves(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_llong(self._attrs_ptr, _encode_string("nbImprovingMoves"))

    def get_nb_infeasible_moves(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_llong(self._attrs_ptr, _encode_string("nbInfeasibleMoves"))

    def get_nb_rejected_moves(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_llong(self._attrs_ptr, _encode_string("nbRejectedMoves"))

    def get_percent_accepted_moves(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_double(self._attrs_ptr, _encode_string("percentAcceptedMoves"))

    def get_percent_improving_moves(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_double(self._attrs_ptr, _encode_string("percentImprovingMoves"))

    def get_percent_rejected_moves(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_double(self._attrs_ptr, _encode_string("percentRejectedMoves"))

    def get_percent_infeasible_moves(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_double(self._attrs_ptr, _encode_string("percentInfeasibleMoves"))

    def __getattr__(self, name):
        _check_optimizer(self._optimizer)
        if not _hx_attrs_is_defined(self._attrs_ptr, _encode_string_no_null(name)): raise AttributeError
        return _get_attr_value(self._attrs_ptr, name)

    def __getitem__(self, name):
        _check_optimizer(self._optimizer)
        if not _hx_attrs_is_defined(self._attrs_ptr, _encode_string_no_null(name)): raise KeyError
        return _get_attr_value(self._attrs_ptr, name)

    def __contains__(self, name):
        _check_optimizer(self._optimizer)
        return _hx_attrs_is_defined(self._attrs_ptr, _encode_string(name))

    def __str__(self):
        _check_optimizer(self._optimizer)
        return _read_string(lambda buf, x: _hx_attrs_to_string(self._attrs_ptr, buf, x))

    def __eq__(self, other):
        return (isinstance(other, HxStatistics)
                and self._attrs_ptr == other._attrs_ptr)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return self._attrs_ptr

    running_time = property(get_running_time)
    nb_iterations = property(get_nb_iterations)
    nb_moves = property(get_nb_moves)
    nb_accepted_moves = property(get_nb_accepted_moves)
    nb_improving_moves = property(get_nb_improving_moves)
    nb_infeasible_moves = property(get_nb_infeasible_moves)
    nb_rejected_moves = property(get_nb_rejected_moves)
    percent_accepted_moves = property(get_percent_accepted_moves)
    percent_improving_moves = property(get_percent_improving_moves)
    percent_rejected_moves = property(get_percent_rejected_moves)
    percent_infeasible_moves = property(get_percent_infeasible_moves)


########


class HxSurrogateParameters(object):
    __slots__ = "_optimizer", "_attrs_ptr", "_func_id"

    def __init__(self, optimizer, func_id):
        self._optimizer = optimizer
        self._func_id = func_id
        self._attrs_ptr = _hx_expr_attrs(optimizer._optimizer_ptr, func_id)

    def get_evaluation_limit(self):
        _check_optimizer(self._optimizer)
        return _hx_attrs_get_int(self._attrs_ptr, _encode_string("evaluationLimit"))

    def set_evaluation_limit(self, evaluation_limit):
        _check_optimizer(self._optimizer)
        _hx_check_modeling_or_stopped(self._optimizer._optimizer_ptr)
        _hx_attrs_set_int(self._attrs_ptr, _encode_string("evaluationLimit"), evaluation_limit)

    def create_evaluation_point(self):
        _check_optimizer(self._optimizer)
        buf = _hx_create_evaluation_point(self._optimizer._optimizer_ptr, self._func_id)
        return HxEvaluationPoint(self._optimizer, buf)

    def get_nb_evaluation_points(self):
        _check_optimizer(self._optimizer)
        return _hx_nb_evaluation_points(self._optimizer._optimizer_ptr, self._func_id)

    def get_evaluation_point(self, pos):
        _check_optimizer(self._optimizer)
        buf = _hx_evaluation_point(self._optimizer._optimizer_ptr, self._func_id, pos)
        return HxEvaluationPoint(self._optimizer, buf)

    evaluation_limit = property(get_evaluation_limit, set_evaluation_limit)
    evaluation_points = property(lambda self: HxContainer("HxEvaluationPoint", self.get_nb_evaluation_points, self.get_evaluation_point))

########


class HxVersion(object):
    __slots__ = "_attrs_ptr", 

    def __init__(self):
        self._attrs_ptr = _hx_globals()

    def get_major_version_number(self):
        return _hx_attrs_get_int(self._attrs_ptr, _encode_string("majorVersion"))

    def get_minor_version_number(self):
        return _hx_attrs_get_int(self._attrs_ptr, _encode_string("minorVersion"))

    def get_build_date(self):
        return _hx_attrs_get_int(self._attrs_ptr, _encode_string("buildDate"))

    def get_platform(self):
        return _read_string(lambda buf, size: _hx_attrs_get_string(
            self._attrs_ptr, _encode_string("platform"), buf, size))

    def get_version(self):
        return _read_string(lambda buf, size: _hx_attrs_get_string(
            self._attrs_ptr, _encode_string("version"), buf, size))

    def get_version_code(self):
        return _hx_version_code()

    def get_copyright(self):
        return _read_string(lambda buf, size: _hx_attrs_get_string(
            self._attrs_ptr, _encode_string("copyright"), buf, size))

    def get_info(self):
        return _read_string(lambda buf, size: _hx_attrs_get_string(
            self._attrs_ptr, _encode_string("info"), buf, size))

    def get_license_path(self):
        return _read_string(lambda buf, size: _hx_attrs_get_string(
            self._attrs_ptr, _encode_string("licensePath"), buf, size))

    def set_license_path(self, path):
        _hx_attrs_set_string(self._attrs_ptr, _encode_string("licensePath"), _encode_string_no_null(path))

    def get_license_content(self):
        return _read_string(lambda buf, size: _hx_attrs_get_string(
            self._attrs_ptr, _encode_string("licenseContent"), buf, size))

    def set_license_content(self, content):
        _hx_attrs_set_string(self._attrs_ptr, _encode_string("licenseContent"), _encode_string_no_null(content))

    major_version_number = property(get_major_version_number)
    minor_version_number = property(get_minor_version_number)
    build_date = property(get_build_date)
    platform = property(get_platform)
    version = property(get_version)
    version_code = property(get_version_code)
    copyright = property(get_copyright)
    info = property(get_info)
    license_path = property(get_license_path, set_license_path)
    license_content = property(get_license_content, set_license_content)

version = HxVersion()
HxVersion = HxVersion()

########



class HxEvaluationPoint(object):
    __slots__ = "_optimizer", "_buffer_ptr"

    def __init__(self, optimizer, buffer_ptr):
        self._optimizer = optimizer
        self._buffer_ptr = buffer_ptr

    def add_argument(self, value):
        _check_optimizer(self._optimizer)
        _hx_check_modeling_or_stopped(self._optimizer._optimizer_ptr)
        x = _extract_python_number(value)
        if isinstance(x, int):
            _hx_buffer_add_int(self._buffer_ptr, x)
        else:
            _hx_buffer_add_double(self._buffer_ptr, x)

    def set_return_value(self, value):
        _check_optimizer(self._optimizer)
        _hx_check_modeling_or_stopped(self._optimizer._optimizer_ptr)
        return_type = _hx_buffer_type(self._buffer_ptr, 0)
        if return_type == _HXVT_ARRAY:
            array_ptr = _hx_buffer_get_buffer(self._buffer_ptr, 0)
            _fill_array(array_ptr, value)
        else:
            x = _extract_python_number(value)
            if isinstance(x, int):
                _hx_buffer_set_int(self._buffer_ptr, 0, x)
            else:
                _hx_buffer_set_double(self._buffer_ptr, 0, x)

    def set_argument(self, pos, value):
        _check_optimizer(self._optimizer)
        _check_positive_argument(pos)
        _hx_check_modeling_or_stopped(self._optimizer._optimizer_ptr)
        x = _extract_python_number(value)
        if isinstance(x, int):
            _hx_buffer_set_int(self._buffer_ptr, pos + 1, x)
        else:
            _hx_buffer_set_double(self._buffer_ptr, pos + 1, x)

    def get_argument(self, pos):
        _check_optimizer(self._optimizer)
        _check_positive_argument(pos)
        arg_type = _hx_buffer_type(self._buffer_ptr, pos + 1)
        if arg_type == _HXVT_INT or arg_type == _HXVT_BOOL:
            return _hx_buffer_get_int(self._buffer_ptr, pos + 1)
        else:
            return _hx_buffer_get_double(self._buffer_ptr, pos + 1)

    def get_return_value(self):
        _check_optimizer(self._optimizer)
        return_type = _hx_buffer_type(self._buffer_ptr, 0)
        if return_type == _HXVT_INT:
            return _hx_buffer_get_int(self._buffer_ptr, 0)
        elif return_type == _HXVT_DOUBLE:
            return _hx_buffer_get_double(self._buffer_ptr, 0)
        else:
            _hx_check_buffer_type(self._buffer_ptr, 0, _HXVT_ARRAY)
            return HxArray(self._optimizer, _hx_buffer_get_buffer(self._buffer_ptr, 0))

    def __hash__(self):
        return self._buffer_ptr

    def __eq__(self, other):
        return (isinstance(other, HxEvaluationPoint)
                and self._buffer_ptr == other._buffer_ptr
                and self._optimizer._optimizer_ptr == other._optimizer._optimizer_ptr)

    def __ne__(self, other):
        return not self.__eq__(other)


########



class HxExpression(object):
    __slots__ = "_optimizer", "_optimizer_ptr", "_expr_id"
    __array_priority__ = 20
    __hash__ = None

    def __init__(self, optimizer, expr_id):
        self._optimizer = optimizer
        self._optimizer_ptr = optimizer._optimizer_ptr
        self._expr_id = expr_id

    def get_operator(self):
        _check_optimizer(self._optimizer)
        return HxOperator[_hx_expr_operator(self._optimizer_ptr, self._expr_id)]

    def get_index(self):
        _check_optimizer(self._optimizer)
        return self._expr_id

    def is_constant(self):
        _check_optimizer(self._optimizer)
        return _hx_expr_operator(self._optimizer_ptr, self._expr_id) == 2

    def is_decision(self):
        _check_optimizer(self._optimizer)
        return _hx_expr_is_decision(self._optimizer_ptr, self._expr_id)

    def is_constraint(self):
        _check_optimizer(self._optimizer)
        return _hx_expr_is_constraint(self._optimizer_ptr, self._expr_id)

    def is_objective(self):
        _check_optimizer(self._optimizer)
        return _hx_expr_is_objective(self._optimizer_ptr, self._expr_id)

    def is_double(self):
        _check_optimizer(self._optimizer)
        return _hx_expr_type(self._optimizer_ptr, self._expr_id) == _HXVT_DOUBLE

    def is_int(self):
        _check_optimizer(self._optimizer)
        expr_type = _hx_expr_type(self._optimizer_ptr, self._expr_id)
        return expr_type == _HXVT_INT or expr_type == _HXVT_BOOL

    def is_bool(self):
        _check_optimizer(self._optimizer)
        return _hx_expr_type(self._optimizer_ptr, self._expr_id) == _HXVT_BOOL

    def is_interval(self):
        _check_optimizer(self._optimizer)
        return _hx_expr_type(self._optimizer_ptr, self._expr_id) == _HXVT_INTERVAL

    def is_array(self):
        _check_optimizer(self._optimizer)
        return _hx_expr_type(self._optimizer_ptr, self._expr_id) == _HXVT_ARRAY

    def is_collection(self):
        _check_optimizer(self._optimizer)
        return _hx_expr_type(self._optimizer_ptr, self._expr_id) == _HXVT_COLLECTION

    def is_function(self):
        _check_optimizer(self._optimizer)
        return _hx_expr_type(self._optimizer_ptr, self._expr_id) == _HXVT_FUNCTION

    def add_operand(self, operand):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        _hx_expr_add_operand(ptr, self._expr_id, _autocreate_expr(ptr, operand))

    def add_operands(self, operands):
        _check_optimizer(self._optimizer)
        if isinstance(operands, HxExpression):
            raise TypeError("An iterable was expected but %s of type HxExpression was found" % operands)
        _expr_add_operands(self._optimizer_ptr, self._expr_id, operands)

    def get_nb_operands(self):
        return _hx_expr_nb_operands(self._optimizer_ptr, self._expr_id)

    def get_operand(self, pos):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _hx_expr_operand(self._optimizer_ptr, self._expr_id, pos))

    def set_operand(self, pos, expr):
        _check_optimizer(self._optimizer)
        opId = _autocreate_expr(self._optimizer_ptr, expr)
        _hx_expr_set_operand(self._optimizer_ptr, self._expr_id, pos, opId)
    
    def set_value(self, value):
        _check_optimizer(self._optimizer)
        if isinstance(value, HxInterval):
            interval = _hxinterval()
            if value.is_void():
                interval.start = 1
                interval.end = 0
            else:
                interval.start = value.start()
                interval.end = value.end()
            _hx_solution_set_interval_value(_hx_best_solution(self._optimizer_ptr), self._expr_id, interval)
            return

        x = _extract_python_number(value)
        if isinstance(x, int):
            expr_type = _hx_expr_type(self._optimizer_ptr, self._expr_id)
            if expr_type == _HXVT_INT or expr_type == _HXVT_BOOL:
                _hx_solution_set_int_value(_hx_best_solution(self._optimizer_ptr), self._expr_id, x)
            else:
                _hx_solution_set_double_value(_hx_best_solution(self._optimizer_ptr), self._expr_id, x)
        else:
            _hx_solution_set_double_value(_hx_best_solution(self._optimizer_ptr), self._expr_id, x)

    def get_value(self):
        _check_optimizer(self._optimizer)
        expr_type = _hx_expr_type(self._optimizer_ptr, self._expr_id)
        solution_ptr = _hx_best_solution(self._optimizer_ptr)
        if expr_type == _HXVT_INT or expr_type == _HXVT_BOOL:
            return _hx_solution_int_value(solution_ptr, self._expr_id)
        elif expr_type == _HXVT_DOUBLE:
            return _hx_solution_double_value(solution_ptr, self._expr_id)
        elif expr_type == _HXVT_INTERVAL:
            interval = _hx_solution_interval_value(solution_ptr, self._expr_id)
            return HxInterval(interval.start, interval.end)
        elif expr_type == _HXVT_COLLECTION:
            buf = _hx_solution_buffer_value(solution_ptr, self._expr_id)
            return HxCollection(self._optimizer, buf, solution_ptr, self._expr_id)
        elif expr_type == _HXVT_ARRAY:
            buf = _hx_solution_buffer_value(solution_ptr, self._expr_id)
            return HxArray(self._optimizer, buf)
        else:
            raise TypeError("This expression doesn't have any value")

    def get_external_context(self):
        _check_optimizer(self._optimizer)
        _hx_check_operator(self._optimizer_ptr, self._expr_id, 43)
        return HxExternalContext(self._optimizer, self._expr_id)

    def is_violated(self):
        _check_optimizer(self._optimizer)
        solution_ptr = _hx_best_solution(self._optimizer_ptr)
        return _hx_solution_is_violated(solution_ptr, self._expr_id)

    def is_undefined(self):
        _check_optimizer(self._optimizer)
        solution_ptr = _hx_best_solution(self._optimizer_ptr)
        return _hx_solution_is_undefined(solution_ptr, self._expr_id)

    def get_name(self):
        _check_optimizer(self._optimizer)
        return _read_string(lambda buf, length: _hx_expr_name(self._optimizer_ptr, self._expr_id, buf, length))

    def set_name(self, name):
        _check_optimizer(self._optimizer)
        _hx_expr_set_name(self._optimizer_ptr, self._expr_id, _encode_string_no_null(name))

    def is_named(self):
        _check_optimizer(self._optimizer)
        return _hx_expr_name(self._optimizer_ptr, self._expr_id, None, 0) > 0

    def __str__(self):
        _check_optimizer(self._optimizer)
        return _read_string(lambda buf, length: _hx_expr_to_string(self._optimizer_ptr, self._expr_id, buf, length))

    def __eq__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 8, self._expr_id, _autocreate_expr(ptr, other)))

    def __ne__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 9, self._expr_id, _autocreate_expr(ptr, other)))

    def __ge__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 10, self._expr_id, _autocreate_expr(ptr, other)))

    def __le__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 11, self._expr_id, _autocreate_expr(ptr, other)))

    def __gt__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 12, self._expr_id, _autocreate_expr(ptr, other)))

    def __lt__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 13, self._expr_id, _autocreate_expr(ptr, other)))

    def __and__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 16, self._expr_id, _autocreate_expr(ptr, other)))

    def __rand__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 16, _autocreate_expr(ptr, other), self._expr_id))

    def __or__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 17, self._expr_id, _autocreate_expr(ptr, other)))

    def __ror__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 17, _autocreate_expr(ptr, other), self._expr_id))

    def __xor__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 18, self._expr_id, _autocreate_expr(ptr, other)))

    def __rxor__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 18, _autocreate_expr(ptr, other), self._expr_id))

    def __invert__(self):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 15, self))

    def __add__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 3, self._expr_id, _autocreate_expr(ptr, other)))

    def __radd__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 3, _autocreate_expr(ptr, other), self._expr_id))

    def __sub__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 4, self._expr_id, _autocreate_expr(ptr, other)))

    def __rsub__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 4, _autocreate_expr(ptr, other), self._expr_id))

    def __mul__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 5, self._expr_id, _autocreate_expr(ptr, other)))

    def __rmul__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 5, _autocreate_expr(ptr, other), self._expr_id))

    def __div__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 21, self._expr_id, _autocreate_expr(ptr, other)))

    def __rdiv__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 21, _autocreate_expr(ptr, other), self._expr_id))

    def __truediv__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 21, self._expr_id, _autocreate_expr(ptr, other)))

    def __rtruediv__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 21, _autocreate_expr(ptr, other), self._expr_id))

    def __floordiv__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        div_expr = _hx_create_expression_2(ptr, 21, self._expr_id, _autocreate_expr(ptr, other))
        return HxExpression(self._optimizer, _hx_create_expression_1(ptr, 27, div_expr))

    def __rfloordiv__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        div_expr = _hx_create_expression_2(ptr, 21, _autocreate_expr(ptr, other), self._expr_id)
        return HxExpression(self._optimizer, _hx_create_expression_1(ptr, 27, div_expr))

    def __pow__(self, other, z=1):
        if (not z is None) and z != 1:
            raise ValueError("Modulo on pow is not supported")
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 32, self._expr_id, _autocreate_expr(ptr, other)))

    def __rpow__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 32, _autocreate_expr(ptr, other), self._expr_id))

    def __mod__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 22, self._expr_id, _autocreate_expr(ptr, other)))

    def __rmod__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 22, _autocreate_expr(ptr, other), self._expr_id))

    def __neg__(self):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 4, _hx_create_int_constant(ptr, 0), self._expr_id))

    def __pos__(self):
        _check_optimizer(self._optimizer)
        return self

    def __abs__(self):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_1(ptr, 19, self._expr_id))

    def __getitem__(self, other):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        return HxExpression(self._optimizer, _hx_create_expression_2(ptr, 24, self._expr_id, _autocreate_expr(ptr, other)))

    def __call__(self, *args):
        _check_optimizer(self._optimizer)
        ptr = self._optimizer_ptr
        expr = _hx_create_expression_1(ptr, 44, self._expr_id)
        _expr_add_operands(ptr, expr, args)
        return HxExpression(self._optimizer, expr)

    def __bool__(self):
        raise TypeError("Cannot transform an HxExpression to a Python boolean. This error appears: "
            "if you tried to use an HxExpression in a boolean statement (such as \"if expr >= obj\"); "
            "if you used an HxExpression as a key in a dictionary; "
            "or if you used Python math functions (like min, max) instead of the dedicated operators implemented in HxModel (HxModel.min, HxModel.max).")

    def __nonzero__(self):
        self.__bool__()

    __iter__ = None

    operator = property(get_operator)
    index = property(get_index)
    nb_operands = property(get_nb_operands)
    operands = property(lambda self: HxMutableContainer("HxExpression", self.get_nb_operands, self.get_operand, self.set_operand))
    name = property(get_name, set_name)
    value = property(get_value, set_value)
    external_context = property(get_external_context)

########


class HxExternalArgumentValues(object):
    __slots__ = "_optimizer", "_buffer_ptr"

    def __init__(self, optimizer, buffer_ptr):
        self._optimizer = optimizer
        self._buffer_ptr = buffer_ptr

    def count(self):
        _check_optimizer(self._optimizer)
        return _hx_buffer_count(self._buffer_ptr)
    
    def is_undefined(self, pos):
        _check_optimizer(self._optimizer)
        return _hx_buffer_is_pos_undefined(self._buffer_ptr, pos) == _HXVT_BOOL

    def is_bool(self, pos):
        _check_optimizer(self._optimizer)
        return _hx_buffer_type(self._buffer_ptr, pos) == _HXVT_BOOL

    def is_int(self, pos):
        _check_optimizer(self._optimizer)
        buf_type = _hx_buffer_type(self._buffer_ptr, pos)
        return buf_type == _HXVT_INT or buf_type == _HXVT_BOOL

    def is_double(self, pos):
        _check_optimizer(self._optimizer)
        return _hx_buffer_type(self._buffer_ptr, pos) == _HXVT_DOUBLE

    def is_interval(self, pos):
        _check_optimizer(self._optimizer)
        return _hx_buffer_type(self._buffer_ptr, pos) == _HXVT_INTERVAL

    def is_collection(self, pos):
        _check_optimizer(self._optimizer)
        return _hx_buffer_type(self._buffer_ptr, pos) == _HXVT_COLLECTION

    def is_array(self, pos):
        _check_optimizer(self._optimizer)
        return _hx_buffer_type(self._buffer_ptr, pos) == _HXVT_ARRAY

    def get(self, pos):
        _check_optimizer(self._optimizer)
        buf_type = _hx_buffer_type(self._buffer_ptr, pos)
        if buf_type == _HXVT_INT or buf_type == _HXVT_BOOL:
            return _hx_buffer_get_int(self._buffer_ptr, pos)
        elif buf_type == _HXVT_DOUBLE:
            return _hx_buffer_get_double(self._buffer_ptr, pos)
        elif buf_type == _HXVT_INTERVAL:
            interval = _hx_buffer_get_interval(self._buffer_ptr, pos)
            return HxInterval(interval.start, interval.end)
        elif buf_type == _HXVT_COLLECTION:
            return HxCollection(self._optimizer, _hx_buffer_get_buffer(self._buffer_ptr, pos))
        elif buf_type == _HXVT_ARRAY:
            return HxArray(self._optimizer, _hx_buffer_get_buffer(self._buffer_ptr, pos))
        else:
            return None

    def __getitem__(self, pos):
        return self.get(pos)
    
    def __len__(self):
        return self.count()

    def __iter__(self):
        n = 0
        while n < self.count():
            yield self.get(n)
            n += 1

    def __str__(self):
        _check_optimizer(self._optimizer)
        return _read_string(lambda buf, x: _hx_buffer_to_string(self._buffer_ptr, buf, x))

    def __eq__(self, other):
        return (isinstance(other, HxExternalArgumentValues)
                and self._buffer_ptr == other._buffer_ptr)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return self._buffer_ptr


########


class HxInconsistency(object):
    __slots__ = "_optimizer", "_optimizer_ptr"

    def __init__(self, optimizer):
        self._optimizer = optimizer
        self._optimizer_ptr = optimizer._optimizer_ptr

    def get_nb_causes(self):
        _check_optimizer(self._optimizer)
        return _hx_iis_nb_causes(self._optimizer_ptr)

    def get_cause(self, causeIndex):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _hx_iis_cause(self._optimizer_ptr, causeIndex))

    def __str__(self):
        _check_optimizer(self._optimizer)
        return _read_string(lambda buf, x: _hx_iis_to_string(self._optimizer_ptr, buf, x))

    def __eq__(self, other):
        return (isinstance(other, HxInconsistency)
                and self._optimizer_ptr == other._optimizer_ptr)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return self._optimizer_ptr

    def __len__(self):
        return self.get_nb_causes()

    def __getitem__(self, pos):
        return self.get_cause(pos)

########


try:
    import numpy
    _HAS_NUMPY = True
except ImportError:
    _HAS_NUMPY = False

class HxModel(object):
    __slots__ = "_optimizer", "_optimizer_ptr"

    def __init__(self, optimizer):
        self._optimizer = optimizer
        self._optimizer_ptr = optimizer._optimizer_ptr

    def close(self):
        _check_optimizer(self._optimizer)
        _hx_close(self._optimizer_ptr)

    def open(self):
        _check_optimizer(self._optimizer)
        _hx_open(self._optimizer_ptr)

    def is_closed(self):
        _check_optimizer(self._optimizer)
        return _hx_is_closed(self._optimizer_ptr)

    def create_constant(self, constant):
        _check_optimizer(self._optimizer)
        x = _extract_python_number(constant)
        if isinstance(x, int):
            return HxExpression(self._optimizer, _hx_create_int_constant(self._optimizer_ptr, x))
        else:
            return HxExpression(self._optimizer, _hx_create_double_constant(self._optimizer_ptr, x))

    def create_const_array(self, values):
        if sys.version_info[0] < 3:
            raise NotImplementedError("Const arrays are only available for Python 3")
        _check_optimizer(self._optimizer)
        if _HAS_NUMPY and isinstance(values, numpy.ndarray) and values.ndim == 1:
            if numpy.issubdtype(values.dtype, numpy.integer):
                c_array = numpy.ascontiguousarray(values, dtype=numpy.int64).ctypes
                return HxExpression(self._optimizer, \
                                    _hx_create_int_const_array(self._optimizer_ptr, c_array.data, c_array.shape[0]))
            elif numpy.issubdtype(values.dtype, numpy.floating):
                c_array = numpy.ascontiguousarray(values, dtype=numpy.float64).ctypes
                return HxExpression(self._optimizer, \
                                    _hx_create_double_const_array(self._optimizer_ptr, c_array.data, c_array.shape[0]))
        if not hasattr(values, "__iter__"):
            raise TypeError("values is not iterable")
        is_integer_array = True
        for value in values:
            if not isinstance(value, numbers.Number):
                raise TypeError("The value " + repr(value) + " is not a number")
            if not isinstance(value, numbers.Integral):
                is_integer_array = False
        values_buf = array.array('q' if is_integer_array else 'd')
        values_buf.extend(values)
        buf_info = values_buf.buffer_info()
        if is_integer_array:
            return HxExpression(self._optimizer, \
                    _hx_create_int_const_array(self._optimizer_ptr, buf_info[0], buf_info[1]))
        return HxExpression(self._optimizer, \
                _hx_create_double_const_array(self._optimizer_ptr, buf_info[0], buf_info[1]))

    def create_lambda_function(self, functor):
        _check_optimizer(self._optimizer)
        if not inspect.isfunction(functor):
            raise TypeError("A function is expected but " + repr(functor) + " was found")

        nb_args = _nb_function_args(functor)
        arguments = [HxExpression(self._optimizer, _expr_create_0(self._optimizer_ptr, 46)) for _ in range(nb_args)]
        arguments.append(functor(*arguments))
        return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, 45, arguments))

    def create_int_external_function(self, func):
        return _create_native_function(self._optimizer, _hx_int_native_function_type, 
                _hx_create_int_external_function, HxExternalArgumentValues, func)

    def create_double_external_function(self, func):
        return _create_native_function(self._optimizer, _hx_double_native_function_type, 
                _hx_create_double_external_function, HxExternalArgumentValues, func)

    def create_int_array_external_function(self, func):
        return _create_array_native_function(self._optimizer, _hx_array_native_function_type,
                _hx_create_int_array_external_function, HxExternalArgumentValues, func, _HXVT_INT)

    def create_double_array_external_function(self, func):
        return _create_array_native_function(self._optimizer, _hx_array_native_function_type,
                _hx_create_double_array_external_function, HxExternalArgumentValues, func, _HXVT_DOUBLE)

    def add_objective(self, expr, direction):
        _check_optimizer(self._optimizer)
        _check_enum(direction, HxObjectiveDirection)
        _hx_add_objective(self._optimizer_ptr, _autocreate_expr(self._optimizer_ptr, expr), direction.value)

    def minimize(self, expr):
        _check_optimizer(self._optimizer)
        self.add_objective(expr, HxObjectiveDirection.MINIMIZE)

    def maximize(self, expr):
        _check_optimizer(self._optimizer)
        self.add_objective(expr, HxObjectiveDirection.MAXIMIZE)

    def get_nb_objectives(self):
        _check_optimizer(self._optimizer)
        return _hx_nb_objectives(self._optimizer_ptr)

    def remove_objective(self, pos):
        _check_optimizer(self._optimizer)
        _hx_remove_objective(self._optimizer_ptr, pos)

    def get_expression(self, posOrName):
        _check_optimizer(self._optimizer)
        if _is_string(posOrName):
            return HxExpression(self._optimizer, _hx_expression_with_name(self._optimizer_ptr, _encode_string_no_null(posOrName)))
        else:
            _hx_check_expr_index(self._optimizer_ptr, posOrName)
            return HxExpression(self._optimizer, posOrName)

    def get_nb_expressions(self):
        _check_optimizer(self._optimizer)
        return _hx_nb_expressions(self._optimizer_ptr)

    def get_objective(self, pos):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _hx_objective(self._optimizer_ptr, pos))

    def get_objective_direction(self, pos):
        _check_optimizer(self._optimizer)
        return HxObjectiveDirection[_hx_objective_direction(self._optimizer_ptr, pos)]

    def get_nb_constraints(self):
        _check_optimizer(self._optimizer)
        return _hx_nb_constraints(self._optimizer_ptr)

    def remove_constraint(self, expr):
        _check_optimizer(self._optimizer)
        if isinstance(expr, int):
            _hx_remove_constraint(self._optimizer_ptr, expr)
        else:
            _hx_remove_constraint_with_expr(self._optimizer_ptr, _find_expr_id(self._optimizer_ptr, expr))

    def get_constraint(self, pos):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _hx_constraint(self._optimizer_ptr, pos))
    
    def add_constraint(self, expr):
        _check_optimizer(self._optimizer)
        _hx_add_constraint(self._optimizer_ptr, _autocreate_expr(self._optimizer_ptr, expr))

    def constraint(self, expr):
        _check_optimizer(self._optimizer)
        self.add_constraint(expr)

    def get_nb_decisions(self):
        _check_optimizer(self._optimizer)
        return _hx_nb_decisions(self._optimizer_ptr)

    def get_decision(self, pos):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _hx_decision(self._optimizer_ptr, pos))

    def get_nb_operands(self):
        _check_optimizer(self._optimizer)
        return _hx_nb_operands(self._optimizer_ptr)

    def create_expression(self, operator, *args):
        _check_optimizer(self._optimizer)
        _check_enum(operator, HxOperator)
        return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, operator.value, args))

    def bool(self):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_0(self._optimizer_ptr, 0))

    def float(self, arg1, arg2):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 1, arg1, arg2))

    def sum(self, *args):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, 3, args))

    def sub(self, arg1, arg2):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 4, arg1, arg2))

    def prod(self, *args):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, 5, args))

    def max(self, *args):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, 6, args))

    def min(self, *args):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, 7, args))

    def eq(self, arg1, arg2):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 8, arg1, arg2))

    def neq(self, arg1, arg2):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 9, arg1, arg2))

    def geq(self, arg1, arg2):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 10, arg1, arg2))

    def leq(self, arg1, arg2):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 11, arg1, arg2))

    def gt(self, arg1, arg2):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 12, arg1, arg2))

    def lt(self, arg1, arg2):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 13, arg1, arg2))

    def iif(self, arg1, arg2, arg3):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_3(self._optimizer_ptr, 14, arg1, arg2, arg3))

    def not_(self, arg1):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 15, arg1))

    def and_(self, *args):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, 16, args))

    def or_(self, *args):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, 17, args))

    def xor(self, *args):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, 18, args))

    def abs(self, arg1):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 19, arg1))

    def dist(self, arg1, arg2):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 20, arg1, arg2))

    def div(self, arg1, arg2):
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 21, arg1, arg2))

    def mod(self, arg1, arg2):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 22, arg1, arg2))

    def array(self, ops=None, opFunc=None, opDefault=None, *args):
        _check_optimizer(self._optimizer)

        if len(args) > 0:
            concat_args = [ops, opFunc, opDefault]
            concat_args.extend(args)
            return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, 23, concat_args))

        if opDefault is not None:
            return HxExpression(self._optimizer, _expr_create_3(self._optimizer_ptr, 23, ops, opFunc, opDefault))
        if opFunc is not None:
            return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 23, ops, opFunc))
        if ops is None:
            return HxExpression(self._optimizer, _expr_create_0(self._optimizer_ptr, 23))
        if isinstance(ops, HxExpression):
            return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 23, ops))

        ptr = self._optimizer_ptr
        created_expr_dict = {}
        def sub_array_creator(sub_array):
            array_type = type(sub_array)
            array_id = id(sub_array)
            if array_type != list or array_id not in created_expr_dict:
                sub_array_expr_id = _expr_create_0(ptr, 23)
                created_expr_dict[array_id] = sub_array_expr_id
                _add_optimized_operands_buffer(ptr, sub_array_expr_id, sub_array, sub_array_creator)
                return sub_array_expr_id
            else:
                return created_expr_dict[array_id]

        root_id = _expr_create_0(ptr, 23)
        created_expr_dict[id(ops)] = root_id
        _add_optimized_operands_buffer(ptr, root_id, ops, sub_array_creator)
        return HxExpression(self._optimizer, root_id)

    def sort(self, array, func=None):
        _check_optimizer(self._optimizer)
        if func is None:
            return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 53, array))
        else:
            return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 53, array, func))

    def at(self, arg1, *args):
        _check_optimizer(self._optimizer)
        concat_args = [arg1]
        concat_args.extend(args)
        return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, 24, concat_args))

    def scalar(self, arg1, arg2):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 25, arg1, arg2))

    def ceil(self, arg1):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 26, arg1))

    def floor(self, arg1):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 27, arg1))

    def round(self, arg1):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 28, arg1))

    def sqrt(self, arg1):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 29, arg1))

    def log(self, arg1):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 30, arg1))

    def exp(self, arg1):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 31, arg1))

    def pow(self, arg1, arg2):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 32, arg1, arg2))

    def cos(self, arg1):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 33, arg1))

    def sin(self, arg1):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 34, arg1))

    def tan(self, arg1):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 35, arg1))

    def int(self, arg1, arg2):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 36, arg1, arg2))

    def piecewise(self, arg1, arg2, arg3):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_3(self._optimizer_ptr, 37, arg1, arg2, arg3))

    def list(self, arg1):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 38, arg1))

    def count(self, arg1):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 39, arg1))

    def index(self, arg1, arg2):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 40, arg1, arg2))

    def partition(self, *args):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, 41, args))

    def disjoint(self, *args):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, 42, args))

    def cover(self, *args):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, 51, args))
    
    def find(self, arg1, arg2):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 52, arg1, arg2))

    def call(self, *args):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, 44, args))

    def range(self, arg1, arg2=None):
        _check_optimizer(self._optimizer)
        range_b = 0 if arg2 is None else arg1
        range_e = arg1 if arg2 is None else arg2
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 47, range_b, range_e))

    def int_external_function(self, func):
        _check_optimizer(self._optimizer)
        return self.create_int_external_function(func)

    def double_external_function(self, func):
        _check_optimizer(self._optimizer)
        return self.create_double_external_function(func)

    def int_array_external_function(self, func):
        _check_optimizer(self._optimizer)
        return self.create_int_array_external_function(func)

    def double_array_external_function(self, func):
        _check_optimizer(self._optimizer)
        return self.create_double_array_external_function(func)

    def lambda_function(self, func):
        _check_optimizer(self._optimizer)
        return self.create_lambda_function(func)

    def contains(self, arg1, arg2):
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 48, arg1, arg2))

    def set(self, arg1):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 49, arg1))

    def interval(self, arg1, arg2):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 54, arg1, arg2))

    def start(self, arg1):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 55, arg1))

    def end(self, arg1):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 56, arg1))

    def length(self, arg1):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 57, arg1))

    def distinct(self, arg1, arg2=None):
        _check_optimizer(self._optimizer)
        if arg2 is None:
            return HxExpression(self._optimizer, _expr_create_1(self._optimizer_ptr, 58, arg1))
        else:
            return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 58, arg1, arg2))
        
    def intersection(self, *args):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, 59, args))
    
    def hull(self, *args):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, 60, args))
    
    def step_array(self, array1, array2):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_2(self._optimizer_ptr, 61, array1, array2))
    
    def union(self, *args):
        _check_optimizer(self._optimizer)
        return HxExpression(self._optimizer, _expr_create_variadic(self._optimizer_ptr, 63, args))

    def __str__(self):
        _check_optimizer(self._optimizer)
        return _read_string(lambda buf, length: _hx_model_to_string(self._optimizer_ptr, buf, length))

    def __eq__(self, other):
        return (isinstance(other, HxModel)
                and self._optimizer_ptr == other._optimizer_ptr)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return self._optimizer_ptr

    nb_objectives = property(get_nb_objectives)
    nb_operands = property(get_nb_operands)
    nb_expressions = property(get_nb_expressions)
    nb_constraints = property(get_nb_constraints)
    nb_decisions = property(get_nb_decisions)
    decisions = property(lambda self: HxContainer("HxExpression", self.get_nb_decisions, self.get_decision))
    expressions = property(lambda self: HxContainer("HxExpression", self.get_nb_expressions, self.get_expression))
    constraints = property(lambda self: HxContainer("HxExpression", self.get_nb_constraints, self.get_constraint))
    objectives = property(lambda self: HxContainer("HxExpression", self.get_nb_objectives, self.get_objective))
    objective_directions = property(lambda self: HxContainer("HxExpression", self.get_nb_objectives, self.get_objective_direction))


########


class HxSolution(object):
    __slots__ = "_optimizer", "_optimizer_ptr", "_solution_ptr"
    
    def __init__(self, optimizer, solution_ptr):
        self._optimizer = optimizer
        self._optimizer_ptr = optimizer._optimizer_ptr
        self._solution_ptr = solution_ptr

    def get_value(self, expr):
        _check_optimizer(self._optimizer)
        if not isinstance(expr, HxExpression):
            raise TypeError("An HxExpression is expected but " + repr(expr) + " was found")
        _check_same_optimizer(self._optimizer_ptr, expr._optimizer_ptr)

        expr_type = _hx_expr_type(self._optimizer_ptr, expr._expr_id)
        if expr_type == _HXVT_INT or expr_type == _HXVT_BOOL:
            return _hx_solution_int_value(self._solution_ptr, expr._expr_id)
        elif expr_type == _HXVT_DOUBLE:
            return _hx_solution_double_value(self._solution_ptr, expr._expr_id)
        elif expr_type == _HXVT_INTERVAL:
            interval = _hx_solution_interval_value(self._solution_ptr, expr._expr_id)
            return HxInterval(interval.start, interval.end)
        elif expr_type == _HXVT_COLLECTION:
            buf = _hx_solution_buffer_value(self._solution_ptr, expr._expr_id)
            return HxCollection(self._optimizer, buf, self._solution_ptr, expr._expr_id)
        elif expr_type == _HXVT_ARRAY:
            return HxArray(self._optimizer, _hx_solution_buffer_value(self._solution_ptr, expr._expr_id))
        else: 
            raise TypeError("This expression doesn't have any value")
            
    def get_objective_bound(self, pos):
        _check_optimizer(self._optimizer)
        expr_id = _hx_objective(self._optimizer_ptr, pos)
        expr_type = _hx_expr_type(self._optimizer_ptr, expr_id)
        if expr_type == _HXVT_INT or expr_type == _HXVT_BOOL:
            return _hx_solution_int_objective_bound(self._solution_ptr, pos)
        else:
            return _hx_solution_double_objective_bound(self._solution_ptr, pos)

    def get_objective_gap(self, pos):
        _check_optimizer(self._optimizer)
        return _hx_solution_objective_gap(self._solution_ptr, pos)

    def set_value(self, expr, value):
        _check_optimizer(self._optimizer)
        if not isinstance(expr, HxExpression):
            raise TypeError("An HxExpression is expected but " + repr(expr) + " was found")
        _check_same_optimizer(self._optimizer_ptr, expr._optimizer_ptr)

        if isinstance(value, HxInterval):
            interval = _hxinterval()
            if value.is_void():
                interval.start = 1
                interval.end = 0
            else:
                interval.start = value.start()
                interval.end = value.end()
            _hx_solution_set_interval_value(self._solution_ptr, expr._expr_id, interval)
            return

        x = _extract_python_number(value)
        if isinstance(x, int):
            expr_type = _hx_expr_type(self._optimizer_ptr, expr._expr_id)
            if expr_type == _HXVT_INT or expr_type == _HXVT_BOOL:
                _hx_solution_set_int_value(self._solution_ptr, expr._expr_id, x)
            else:
                _hx_solution_set_double_value(self._solution_ptr, expr._expr_id, x)
        else:
            _hx_solution_set_double_value(self._solution_ptr, expr._expr_id, x)

    def is_violated(self, expr):
        _check_optimizer(self._optimizer)

        if not isinstance(expr, HxExpression):
            raise TypeError("An HxExpression is expected but " + repr(expr) + " was found")

        _check_same_optimizer(self._optimizer_ptr, expr._optimizer_ptr)
        return _hx_solution_is_violated(self._solution_ptr, expr._expr_id)

    def is_undefined(self, expr):
        _check_optimizer(self._optimizer)

        if not isinstance(expr, HxExpression):
            raise TypeError("An HxExpression is expected but " + repr(expr) + " was found")

        _check_same_optimizer(self._optimizer_ptr, expr._optimizer_ptr)
        return _hx_solution_is_undefined(self._solution_ptr, expr._expr_id)

    def get_status(self):
        _check_optimizer(self._optimizer)
        return HxSolutionStatus[_hx_solution_status(self._solution_ptr)]

    def clear(self):
        _check_optimizer(self._optimizer)
        _hx_solution_clear(self._solution_ptr)

    def __eq__(self, other):
        return (isinstance(other, HxSolution)
                and self._solution_ptr == other._solution_ptr)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return self._solution_ptr

    status = property(get_status)


########


class HexalyOptimizer(object):
    __slots__ = "_optimizer_ptr", "_handle_modeler_ptr", "_optimizer_modeler_ptr", "_callbacks", "_native_functions", "_model", "_stats", "_param", "_solution"

    def __init__(self, optimizer_ptr=None, handle_modeler_ptr=None, optimizer_modeler_ptr=None):
        self._optimizer_ptr = None
        self._handle_modeler_ptr = None
        self._optimizer_modeler_ptr = None
        self._callbacks = []
        self._native_functions = []
        self._model = None
        self._stats = None
        self._param = None
        self._solution = None

        if optimizer_ptr is None:
            self._optimizer_ptr = _hx_create_optimizer()
        else:
            self._optimizer_ptr = optimizer_ptr
            self._handle_modeler_ptr = handle_modeler_ptr
            self._optimizer_modeler_ptr = optimizer_modeler_ptr
            _hxm_inc_ref(handle_modeler_ptr)
            _hxm_inc_ref(optimizer_modeler_ptr)

        self.get_param().set_log_writer(sys.stdout)

        # Add a periodic callback to let the Python VM propagate signals (Ctrl+C)
        cb = (self, None, HxCallbackType.TIME_TICKED, _hx_callback_type(lambda _1, _2, _3: None))
        params = _hxcallbackparams()
        params.timeBetweenTicks = 1
        params.system = True
        self._callbacks.append(cb)
        _hx_add_callback_2(self._optimizer_ptr, HxCallbackType.TIME_TICKED.value, cb[3], params, None)

    def __del__(self):
        if self._handle_modeler_ptr is not None:
            _hxm_optimizer_reset(self._optimizer_modeler_ptr)
            _hxm_dec_ref(self._optimizer_modeler_ptr)
            _hxm_dec_ref(self._handle_modeler_ptr)
        elif self._optimizer_ptr is not None:
            _hx_delete_optimizer(self._optimizer_ptr)

        self._optimizer_ptr = None
        self._optimizer_modeler_ptr = None
        self._handle_modeler_ptr = None

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.__del__()

    def delete(self):
        self.__del__()

    def get_state(self):
        _check_optimizer(self)
        return HxState[_hx_state(self._optimizer_ptr)]

    def get_model(self):
        _check_optimizer(self)
        if self._model is not None:
            return self._model
        self._model = HxModel(self)
        return self._model

    def get_param(self):
        _check_optimizer(self)
        if self._param is not None:
            return self._param
        self._param = HxParam(self)
        return self._param

    def solve(self):
        _check_optimizer(self)
        # Required since Jupyter overwrites the signal handler previously set without chaining it.
        _hx_define_signal_handler("SIGINT")
        _hx_solve(self._optimizer_ptr)

    def compute_inconsistency(self):
        _check_optimizer(self)
        _hx_compute_iis(self._optimizer_ptr)
        return HxInconsistency(self)

    def stop(self):
        _check_optimizer(self)
        _hx_stop(self._optimizer_ptr)

    def create_phase(self):
        _check_optimizer(self)
        return HxPhase(self, _hx_add_phase(self._optimizer_ptr))

    def get_phase(self, pos):
        _check_optimizer(self)
        return HxPhase(self, _hx_phase(self._optimizer_ptr, pos))

    def get_nb_phases(self):
        _check_optimizer(self)
        return _hx_nb_phases(self._optimizer_ptr)

    def get_solution(self):
        _check_optimizer(self)
        if self._solution is not None:
            return self._solution
        self._solution = HxSolution(self, _hx_best_solution(self._optimizer_ptr))
        return self._solution

    def get_statistics(self):
        _check_optimizer(self)
        if self._stats is not None:
            return self._stats
        self._stats = HxStatistics(self)
        return self._stats

    def save_environment(self, filename):
        _check_optimizer(self)
        _hx_save_environment(self._optimizer_ptr, _encode_string_no_null(filename))

    def load_environment(self, filename):
        _check_optimizer(self)
        _hx_load_environment(self._optimizer_ptr, _encode_string_no_null(filename))

    def __str__(self):
        _check_optimizer(self)
        return _read_string(lambda buf, length: _hx_to_string(self._optimizer_ptr, buf, length))

    def add_callback(self, cb_type, func):
        _check_optimizer(self)
        _check_enum(cb_type, HxCallbackType)

        def callback(_1, cb_type, _2):
            global _pending_error
            try:
                func(self, HxCallbackType[cb_type])
            except:
                _pending_error = sys.exc_info()[1]
                _hx_interrupt(_encode_string(repr(_pending_error)), None)

        cb = (self, func, cb_type, _hx_callback_type(callback))
        self._callbacks.append(cb)
        _hx_add_callback(self._optimizer_ptr, cb_type.value, cb[3], None)

    def remove_callback(self, cb_type, func):
        _check_optimizer(self)
        for cb in self._callbacks:
            if cb[1] == func and cb[2] == cb_type:
                return _hx_remove_callback(self._optimizer_ptr, cb_type.value, cb[3])
        self._callbacks = [cb for cb in self._callbacks if not(cb[1] == func and cb[2] == cb_type)]

    def __eq__(self, other):
        return (isinstance(other, HexalyOptimizer)
                and self._optimizer_ptr == other._optimizer_ptr)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return self._optimizer_ptr

    state = property(get_state)
    statistics = property(get_statistics)
    model = property(get_model)
    param = property(get_param)
    solution = property(get_solution)
    nb_phases = property(get_nb_phases)
    phases = property(lambda self: HxContainer("HxPhase", self.get_nb_phases, self.get_phase))



########

